<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ポケポケ 勝敗記録</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="apple-touch-icon" href="icons/app-icon.png">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
      margin: 0;
      padding: 0;
      background: #f4f6fb;
    }
    header {
      background: #2563eb;
      color: white;
      padding: 12px 16px;
      font-size: 20px;
      font-weight: bold;
    }
    main {
      padding: 12px 16px 40px;
      max-width: 900px;
      margin: 0 auto;
    }
    .card {
      background: white;
      border-radius: 12px;
      padding: 12px 14px;
      margin-bottom: 12px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .card h2 {
      margin: 0 0 6px;
      font-size: 16px;
    }
    .card small {
      color: #6b7280;
    }
    label {
      font-size: 13px;
      display: block;
      margin: 6px 0 2px;
    }
    input[type="text"],
    input[type="date"],
    textarea,
    select {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-size: 13px;
      background: #ffffff;
    }
    textarea {
      min-height: 50px;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 13px;
      cursor: pointer;
    }
    .btn-main {
      background: #2563eb;
      color: white;
    }
    .btn-sub {
      background: #e5e7eb;
      color: #374151;
    }
    .row {
      display: flex;
      gap: 8px;
    }
    .row > div {
      flex: 1;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    th, td {
      border-bottom: 1px solid #e5e7eb;
      padding: 4px 6px;
      text-align: left;
    }
    th {
      background: #f3f4f6;
    }
    .tag-win {
      color: #1d4ed8;
      font-weight: bold;
    }
    .tag-lose {
      color: #b91c1c;
      font-weight: bold;
    }
    .tag-draw {
      color: #6b7280;
      font-weight: bold;
    }
    .tag-order {
      font-size: 11px;
      padding: 1px 6px;
      border-radius: 999px;
      background: #e5e7eb;
      margin-left: 4px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px;
      font-size: 13px;
    }
    .stat-box {
      padding: 6px 8px;
      border-radius: 10px;
      background: #eff6ff;
    }
    .stat-title {
      font-size: 12px;
      color: #4b5563;
    }
    .stat-main {
      font-size: 16px;
      font-weight: bold;
    }
    .stat-sub {
      font-size: 12px;
      color: #6b7280;
    }
    .muted {
      color: #6b7280;
      font-size: 12px;
    }
    .type-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      object-fit: cover;
      margin-right: 4px;
      vertical-align: middle;
    }
    .type-preview {
      margin-top: 4px;
      font-size: 12px;
      color: #4b5563;
      display: flex;
      align-items: center;
      min-height: 22px;
      cursor: pointer;
    }
    .type-preview span {
      margin-left: 4px;
      font-size: 11px;
      color: #6b7280;
    }
    .type-picker {
      position: relative;
      margin-top: 2px;
    }
    .type-panel {
      position: relative;
      margin-top: 4px;
      padding: 6px;
      border-radius: 10px;
      background: #f3f4ff;
      display: none;
      flex-wrap: wrap;
      gap: 6px;
    }
    .type-panel.open {
      display: flex;
    }
    .type-btn {
      border-radius: 999px;
      padding: 4px;
      background: white;
      border: 1px solid #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
    }
    .type-btn img {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      object-fit: cover;
    }
    canvas {
      width: 100%;
      height: 200px;
      display: block;
    }
    /* スランプ値の色 */
    .slump-plus {
      color: #2563eb;
      font-weight: bold;
    }
    .slump-minus {
      color: #dc2626;
      font-weight: bold;
    }
    .slump-zero {
      color: #6b7280;
    }
    /* 属性マトリクス用 */
    #typeMatrixTable th,
    #typeMatrixTable td {
      text-align: center;
      font-size: 11px;
      padding: 4px;
    }
    #deckStatsTable th,
    #deckStatsTable td {
      font-size: 12px;
    }

    /* ★ デッキ名＋カード画像用（ズレ修正） */
    .deck-cell {
      display: flex;
      align-items: center;    /* 縦位置を中央揃え */
      gap: 4px;
    }
    .deck-cell .card-thumb {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      object-fit: cover;
    }
  </style>
</head>
<body>
<header>
  ポケポケ 勝敗記録（Web版）
</header>

<main>
  <!-- 入力フォーム -->
  <section class="card">
    <h2>対戦を記録</h2>
    <div class="row">
      <div>
        <label>日付</label>
        <input type="date" id="dateInput">
      </div>
      <div>
        <label>自分のデッキ</label>
        <select id="myDeckPreset" onchange="applyDeckPreset('my')">
          <option value="">▼ 履歴から選択（任意）</option>
        </select>
        <input type="text" id="myDeckInput" placeholder="例）エビワラー" />
      </div>
    </div>

    <label>相手のデッキ</label>
    <select id="opponentDeckPreset" onchange="applyDeckPreset('opp')">
      <option value="">▼ 履歴から選択（任意）</option>
    </select>
    <input type="text" id="opponentDeckInput" placeholder="例）水デッキ" />

    <div class="row">
      <div>
        <label>自分の属性</label>
        <input type="hidden" id="typeInput">
        <div class="type-picker">
          <div id="selfTypePreview" class="type-preview" onclick="toggleTypePanel('self')">
            <span>タップして属性を選択</span>
          </div>
          <div id="selfTypePanel" class="type-panel">
            <button type="button" class="type-btn" onclick="selectType('self','fire')">
              <img src="icons/fire.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','water')">
              <img src="icons/water.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','grass')">
              <img src="icons/grass.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','lightning')">
              <img src="icons/lightning.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','psychic')">
              <img src="icons/psychic.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','darkness')">
              <img src="icons/darkness.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','fighting')">
              <img src="icons/fighting.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','metal')">
              <img src="icons/metal.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','colorless')">
              <img src="icons/colorless.png" alt="">
            </button>
          </div>
        </div>
      </div>

      <div>
        <label>相手の属性</label>
        <input type="hidden" id="opponentTypeInput">
        <div class="type-picker">
          <div id="oppTypePreview" class="type-preview" onclick="toggleTypePanel('opp')">
            <span>タップして属性を選択</span>
          </div>
          <div id="oppTypePanel" class="type-panel">
            <button type="button" class="type-btn" onclick="selectType('opp','fire')">
              <img src="icons/fire.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','water')">
              <img src="icons/water.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','grass')">
              <img src="icons/grass.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','lightning')">
              <img src="icons/lightning.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','psychic')">
              <img src="icons/psychic.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','darkness')">
              <img src="icons/darkness.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','fighting')">
              <img src="icons/fighting.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','metal')">
              <img src="icons/metal.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','colorless')">
              <img src="icons/colorless.png" alt="">
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div>
        <label>結果</label>
        <select id="resultInput" onchange="updateResultColor()">
          <option value="win">勝ち</option>
          <option value="lose">負け</option>
          <option value="draw">引き分け</option>
        </select>
      </div>
      <div>
        <label>先攻 / 後攻</label>
        <select id="orderInput">
          <option value="first">先攻</option>
          <option value="second">後攻</option>
        </select>
      </div>
    </div>

    <label>メモ</label>
    <textarea id="memoInput" placeholder="例）サイド差2枚で押し切り、事故、じゃんけん負けなど"></textarea>

    <div style="margin-top:8px; display:flex; gap:8px; justify-content:flex-end;">
      <button class="btn-sub" type="button" onclick="clearForm()">リセット</button>
      <button id="submitButton" class="btn-main" type="button" onclick="addRecord()">記録を追加</button>
    </div>
    <p class="muted">※ ブラウザの中に自動保存されます（localStorage使用）。</p>
  </section>

  <!-- 成績サマリ -->
  <section class="card">
    <h2>成績サマリー</h2>
    <div class="stats-grid">
      <div class="stat-box">
        <div class="stat-title">トータル</div>
        <div class="stat-main" id="totalText">0戦</div>
        <div class="stat-sub" id="wlText">勝0 / 負0 / 分0</div>
      </div>
      <div class="stat-box">
        <div class="stat-title">総合勝率（引き分け除く）</div>
        <div class="stat-main" id="winRateText">0.0%</div>
        <div class="stat-sub">（勝 / （勝+負））</div>
      </div>
      <div class="stat-box">
        <div class="stat-title">先攻 勝率</div>
        <div class="stat-main" id="firstRateText">0.0%</div>
        <div class="stat-sub" id="firstDetailText">0勝 0敗</div>
      </div>
      <div class="stat-box">
        <div class="stat-title">後攻 勝率</div>
        <div class="stat-main" id="secondRateText">0.0%</div>
        <div class="stat-sub" id="secondDetailText">0勝 0敗</div>
      </div>
    </div>
  </section>

  <!-- 勝率グラフ -->
  <section class="card">
    <h2>勝率の推移</h2>
    <small>勝ち / 負けのみで計算（引き分けは除外）｜下の数字は「何戦目」｜50％ライン濃い線：上＝青／下＝赤</small>
    <canvas id="winrateCanvas"></canvas>
  </section>

  <!-- スランプグラフ -->
  <section class="card">
    <h2>スランプグラフ</h2>
    <small>勝ち +1 / 負け −1 / 引き分け 0 の累計（古い対戦から順に）｜左に累計ポイント｜下の数字は「何戦目」</small>
    <canvas id="slumpCanvas"></canvas>
    <small id="slumpInfo" class="muted"></small><br>
    <small class="muted">
      最高連勝：<span id="maxWinText">0連勝</span>　｜　
      最高連敗：<span id="maxLoseText">0連敗</span>
    </small><br>
    <small class="muted">
      現在の連勝：<span id="curWinText">0連勝</span>　｜　
      現在の連敗：<span id="curLoseText">0連敗</span>
    </small>
  </section>

  <!-- デッキ別戦績 -->
  <section class="card">
    <h2>デッキ別戦績（自分のデッキ）</h2>
    <div style="overflow-x:auto;">
      <table id="deckStatsTable">
        <thead>
          <tr>
            <th>デッキ名</th>
            <th>対戦数</th>
            <th>勝</th>
            <th>負</th>
            <th>分</th>
            <th>勝率</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- 属性×属性 勝率 -->
  <section class="card">
    <h2>属性 × 属性 勝率</h2>
    <small>行：自分の属性 ／ 列：相手の属性</small>
    <div style="overflow-x:auto;">
      <table id="typeMatrixTable"></table>
    </div>
  </section>

  <!-- 対戦一覧 -->
  <section class="card">
    <h2>対戦履歴</h2>
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
      <small id="countText">0件</small>
      <div style="display:flex; gap:6px;">
        <button class="btn-sub" type="button" onclick="backupData()" style="font-size:11px;">バックアップ</button>
        <button class="btn-sub" type="button" onclick="restoreData()" style="font-size:11px;">復元</button>
        <button class="btn-sub" type="button" onclick="clearAll()" style="font-size:11px;">全消去</button>
      </div>
    </div>
    <div style="overflow-x:auto;">
      <table id="recordsTable">
        <thead>
          <tr>
            <th>日付</th>
            <th>自分のデッキ</th>
            <th>相手のデッキ</th>
            <th>結果</th>
            <th>スランプ</th>
            <th>メモ</th>
            <th></th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>
</main>

<script>
  const TYPE_KEYS = ["fire","water","grass","lightning","psychic","darkness","fighting","metal","colorless"];
  const TYPE_LABEL = {
    fire: "炎", water: "水", grass: "草",
    lightning: "雷", psychic: "超", darkness: "悪",
    fighting: "闘", metal: "鋼", colorless: "無"
  };

  // ★ デッキ名 → カード画像ファイル（自分の cards フォルダに合わせて自由に編集）
  const DECK_IMAGE_MAP = {
    "エビワラー": "cards/ebihit.png"
    // 例: "ロストギラティナ": "cards/lost_gira.png",
    //     "パオジアン": "cards/paojian.png"
  };

  let records = [];
  let editingId = null;

  function loadData() {
    const raw = localStorage.getItem("pokepokeRecords");
    if (raw) {
      try { records = JSON.parse(raw); } catch(e) { records = []; }
    }
  }
  function saveData() {
    localStorage.setItem("pokepokeRecords", JSON.stringify(records));
  }

  function formatDate(iso) {
    if (!iso) return "";
    const d = new Date(iso);
    if (isNaN(d.getTime())) return iso;
    const y = d.getFullYear();
    const m = ("0"+(d.getMonth()+1)).slice(-2);
    const day = ("0"+d.getDate()).slice(-2);
    return `${y}/${m}/${day}`;
  }
  function resultLabel(r) {
    if (r === "win") return "勝ち";
    if (r === "lose") return "負け";
    if (r === "draw") return "引き分け";
    return "";
  }
  function orderLabel(o) {
    if (o === "first") return "先攻";
    if (o === "second") return "後攻";
    return "";
  }
  function resultClass(r) {
    if (r === "win") return "tag-win";
    if (r === "lose") return "tag-lose";
    return "tag-draw";
  }
  function typeIconSrc(t) {
    if (!t) return null;
    return "icons/" + t + ".png";
  }

  function applyDeckPreset(which) {
    if (which === "my") {
      const val = document.getElementById("myDeckPreset").value;
      if (val) document.getElementById("myDeckInput").value = val;
    } else {
      const val = document.getElementById("opponentDeckPreset").value;
      if (val) document.getElementById("opponentDeckInput").value = val;
    }
  }

  function renderDeckPresets() {
    const mySel = document.getElementById("myDeckPreset");
    const oppSel = document.getElementById("opponentDeckPreset");
    if (!mySel || !oppSel) return;

    const mySet = new Set();
    const oppSet = new Set();
    records.forEach(r => {
      if (r.myDeck && r.myDeck.trim()) mySet.add(r.myDeck.trim());
      if (r.opponentDeck && r.opponentDeck.trim()) oppSet.add(r.opponentDeck.trim());
    });

    function fillSelect(sel, set, ph) {
      sel.innerHTML = "";
      const o0 = document.createElement("option");
      o0.value = "";
      o0.textContent = ph;
      sel.appendChild(o0);
      Array.from(set).sort().forEach(name => {
        const o = document.createElement("option");
        o.value = name;
        o.textContent = name;
        sel.appendChild(o);
      });
    }
    fillSelect(mySel, mySet, "▼ 履歴から選択（任意）");
    fillSelect(oppSel, oppSet, "▼ 履歴から選択（任意）");
  }

  function toggleTypePanel(who) {
    const selfPanel = document.getElementById("selfTypePanel");
    const oppPanel = document.getElementById("oppTypePanel");
    if (who === "self") {
      const open = !selfPanel.classList.contains("open");
      selfPanel.classList.toggle("open", open);
      oppPanel.classList.remove("open");
    } else {
      const open = !oppPanel.classList.contains("open");
      oppPanel.classList.toggle("open", open);
      selfPanel.classList.remove("open");
    }
  }

  function selectType(who, type) {
    if (who === "self") {
      document.getElementById("typeInput").value = type;
      updateSelfPreview();
      document.getElementById("selfTypePanel").classList.remove("open");
    } else {
      document.getElementById("opponentTypeInput").value = type;
      updateOpponentPreview();
      document.getElementById("oppTypePanel").classList.remove("open");
    }
  }

  function updateSelfPreview() {
    const t = document.getElementById("typeInput").value;
    const c = document.getElementById("selfTypePreview");
    c.innerHTML = "";
    if (!t) {
      const span = document.createElement("span");
      span.textContent = "タップして属性を選択";
      c.appendChild(span);
      return;
    }
    const src = typeIconSrc(t);
    if (src) {
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.className = "type-icon";
      c.appendChild(img);
    }
  }

  function updateOpponentPreview() {
    const t = document.getElementById("opponentTypeInput").value;
    const c = document.getElementById("oppTypePreview");
    c.innerHTML = "";
    if (!t) {
      const span = document.createElement("span");
      span.textContent = "タップして属性を選択";
      c.appendChild(span);
      return;
    }
    const src = typeIconSrc(t);
    if (src) {
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.className = "type-icon";
      c.appendChild(img);
    }
  }

  function sortedByDateAsc() {
    return records.slice().sort((a,b)=>{
      const ad = a.date || "";
      const bd = b.date || "";
      if (ad < bd) return -1;
      if (ad > bd) return 1;
      return (a.id||0)-(b.id||0);
    });
  }

  function calcSlumpPoints() {
    const sorted = sortedByDateAsc();
    let value = 0;
    const pts = [];
    for (const r of sorted) {
      if (r.result === "win") value += 1;
      else if (r.result === "lose") value -= 1;
      pts.push(value);
    }
    return pts;
  }

  function calcSlumpMap() {
    const sorted = sortedByDateAsc();
    let value = 0;
    const map = {};
    sorted.forEach((r,i)=>{
      if (r.result === "win") value += 1;
      else if (r.result === "lose") value -= 1;
      map[r.id] = value;
      r.battleNumber = i+1;
    });
    return map;
  }

  function calcStreaks() {
    let maxWin=0,maxLose=0,curWin=0,curLose=0;
    sortedByDateAsc().forEach(r=>{
      if (r.result === "win") {
        curWin++; curLose=0;
        if (curWin>maxWin) maxWin=curWin;
      } else if (r.result === "lose") {
        curLose++; curWin=0;
        if (curLose>maxLose) maxLose=curLose;
      } else {
        curWin=0; curLose=0;
      }
    });
    return {maxWin,maxLose,curWin,curLose};
  }

  function calcWinRatePoints() {
    const sorted = sortedByDateAsc();
    let w=0,l=0;
    const pts=[];
    for (const r of sorted) {
      if (r.result==="win") w++;
      else if (r.result==="lose") l++;
      const b = w+l;
      const rate = b===0?0:(w/b*100);
      pts.push(rate);
    }
    return pts;
  }

  function renderSlumpGraph() {
    const canvas = document.getElementById("slumpCanvas");
    const info = document.getElementById("slumpInfo");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");

    const rect = canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    canvas.width = width;
    canvas.height = height;

    ctx.clearRect(0,0,width,height);

    const points = calcSlumpPoints();
    const {maxWin,maxLose,curWin,curLose} = calcStreaks();

    const maxWinEl = document.getElementById("maxWinText");
    const maxLoseEl = document.getElementById("maxLoseText");
    const curWinEl = document.getElementById("curWinText");
    const curLoseEl = document.getElementById("curLoseText");

    if (maxWinEl) {
      maxWinEl.textContent = `${maxWin}連勝`;
      maxWinEl.style.color = maxWin>0 ? "#2563eb" : "#6b7280";
    }
    if (maxLoseEl) {
      maxLoseEl.textContent = `${maxLose}連敗`;
      maxLoseEl.style.color = maxLose>=2 ? "#dc2626" : "#6b7280";
    }
    if (curWinEl) {
      curWinEl.textContent = `${curWin}連勝`;
      curWinEl.style.color = curWin>0 ? "#2563eb" : "#6b7280";
    }
    if (curLoseEl) {
      curLoseEl.textContent = `${curLose}連敗`;
      curLoseEl.style.color = curLose>=2 ? "#dc2626" : "#6b7280";
    }

    if (!points.length) {
      if (info) {
        info.textContent = "まだデータがありません";
        info.style.color = "#6b7280";
      }
      ctx.fillStyle = "#9ca3af";
      ctx.font = "12px -apple-system, BlinkMacSystemFont, sans-serif";
      ctx.fillText("まだデータがありません", 10, height/2);
      return;
    } else {
      const last = points[points.length-1];
      const sign = last>0?"+":"";
      if (info) {
        info.textContent = `現在の累計：${sign}${last}`;
        info.style.color = last>0 ? "#2563eb" : last<0 ? "#dc2626" : "#6b7280";
      }
    }

    const maxVal = Math.max(...points,0);
    const minVal = Math.min(...points,0);
    const range = Math.max(maxVal-minVal,1);

    const padding = 32;
    const usableW = width - padding*2;
    const usableH = height - padding*2;

    ctx.fillStyle = "#f9fafb";
    ctx.fillRect(padding, padding, usableW, usableH);

    ctx.setLineDash([4,4]);
    ctx.strokeStyle = "#e5e7eb";
    ctx.lineWidth = 1;
    const gridCount = 4;
    for (let i=0;i<=gridCount;i++){
      const y = padding + usableH*i/gridCount;
      ctx.beginPath();
      ctx.moveTo(padding,y);
      ctx.lineTo(width-padding,y);
      ctx.stroke();
    }
    ctx.setLineDash([]);

    const zeroY = padding + usableH*(maxVal/range);
    ctx.strokeStyle = "#4b5563";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(padding,zeroY);
    ctx.lineTo(width-padding,zeroY);
    ctx.stroke();

    function pointToXY(idx,v){
      const ratio = points.length===1?0.5:idx/(points.length-1);
      const x = padding + usableW*ratio;
      const y = padding + usableH*((maxVal-v)/range);
      return {x,y};
    }

    ctx.lineWidth = 2;
    for (let i=1;i<points.length;i++){
      const v1 = points[i-1];
      const v2 = points[i];
      const {x:x1,y:y1} = pointToXY(i-1,v1);
      const {x:x2,y:y2} = pointToXY(i,v2);
      const avg = (v1+v2)/2;
      ctx.strokeStyle = avg>=0 ? "#2563eb" : "#dc2626";
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }

    for (let i=0;i<points.length;i++){
      const v = points[i];
      const {x,y} = pointToXY(i,v);
      ctx.fillStyle = v>=0 ? "#2563eb" : "#dc2626";
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = "#6b7280";
    ctx.font = "10px -apple-system, BlinkMacSystemFont, sans-serif";
    for (let i=0;i<points.length;i++){
      const {x} = pointToXY(i,points[i]);
      ctx.fillText(String(i+1), x-3, height-5);
    }

    const minY = Math.floor(minVal);
    const maxY = Math.ceil(maxVal);
    for (let v=minY; v<=maxY; v++){
      const y = padding + usableH*((maxVal - v)/range);
      ctx.fillText(String(v), 6, y+3);
    }
  }

  function renderWinRateGraph() {
    const canvas = document.getElementById("winrateCanvas");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");

    const rect = canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    canvas.width = width;
    canvas.height = height;

    ctx.clearRect(0,0,width,height);

    const points = calcWinRatePoints();
    if (points.length===0 || points.every(v=>v===0)){
      ctx.fillStyle = "#9ca3af";
      ctx.font = "12px -apple-system, BlinkMacSystemFont, sans-serif";
      ctx.fillText("勝ち負けの対戦がまだありません", 10, height/2);
      return;
    }

    const maxVal = Math.max(...points,100);
    const minVal = 0;
    const range = Math.max(maxVal-minVal,1);

    const padding = 32;
    const usableW = width - padding*2;
    const usableH = height - padding*2;

    ctx.fillStyle = "#f9fafb";
    ctx.fillRect(padding,padding,usableW,usableH);

    const levels = [0,25,50,75,100];
    ctx.font = "10px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.fillStyle = "#6b7280";
    levels.forEach(lv=>{
      const ratio = (lv-minVal)/range;
      const y = padding + usableH*(1-ratio);
      if (lv===50){
        ctx.setLineDash([]);
        ctx.strokeStyle = "#4b5563";
        ctx.lineWidth = 3;
      } else {
        ctx.setLineDash([4,4]);
        ctx.strokeStyle = "#e5e7eb";
        ctx.lineWidth = 1;
      }
      ctx.beginPath();
      ctx.moveTo(padding,y);
      ctx.lineTo(width-padding,y);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText(lv+"%", 4, y+3);
    });

    function pointToXY(idx,v){
      const ratio = points.length===1?0.5:idx/(points.length-1);
      const x = padding + usableW*ratio;
      const yRatio = (v-minVal)/range;
      const y = padding + usableH*(1-yRatio);
      return {x,y};
    }

    ctx.lineWidth = 2;
    for (let i=1;i<points.length;i++){
      const v1=points[i-1];
      const v2=points[i];
      const {x:x1,y:y1} = pointToXY(i-1,v1);
      const {x:x2,y:y2} = pointToXY(i,v2);
      const avg = (v1+v2)/2;
      ctx.strokeStyle = avg>=50 ? "#2563eb" : "#dc2626";
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }

    points.forEach((v,i)=>{
      const {x,y} = pointToXY(i,v);
      ctx.beginPath();
      ctx.arc(x,y,3,0,Math.PI*2);
      ctx.fillStyle = v>=50 ? "#2563eb" : "#dc2626";
      ctx.fill();
    });

    ctx.fillStyle = "#6b7280";
    ctx.font = "10px -apple-system, BlinkMacSystemFont, sans-serif";
    points.forEach((v,i)=>{
      const {x} = pointToXY(i,v);
      ctx.fillText(String(i+1), x-3, height-5);
    });
  }

  function addRecord() {
    const date = document.getElementById("dateInput").value;
    const myDeck = document.getElementById("myDeckInput").value.trim();
    const opponentDeck = document.getElementById("opponentDeckInput").value.trim();
    const type = document.getElementById("typeInput").value;
    const opponentType = document.getElementById("opponentTypeInput").value;
    const result = document.getElementById("resultInput").value;
    const order = document.getElementById("orderInput").value;
    const memo = document.getElementById("memoInput").value.trim();

    if (editingId !== null) {
      const idx = records.findIndex(r=>r.id===editingId);
      if (idx!==-1){
        records[idx] = {...records[idx], date,myDeck,opponentDeck,type,opponentType,result,order,memo};
      }
    } else {
      const rec = {id:Date.now(),date,myDeck,opponentDeck,type,opponentType,result,order,memo};
      records.push(rec);
    }

    saveData();
    editingId = null;
    const btn = document.getElementById("submitButton");
    if (btn) btn.textContent = "記録を追加";
    render();
    clearForm();
  }

  function clearForm() {
    const today = new Date().toISOString().slice(0,10);
    document.getElementById("dateInput").value = today;
    document.getElementById("myDeckInput").value = "";
    document.getElementById("opponentDeckInput").value = "";
    document.getElementById("myDeckPreset").value = "";
    document.getElementById("opponentDeckPreset").value = "";
    document.getElementById("typeInput").value = "";
    document.getElementById("opponentTypeInput").value = "";
    document.getElementById("resultInput").value = "win";
    document.getElementById("orderInput").value = "first";
    document.getElementById("memoInput").value = "";
    editingId = null;
    const btn = document.getElementById("submitButton");
    if (btn) btn.textContent = "記録を追加";
    updateSelfPreview();
    updateOpponentPreview();
    updateResultColor();
    document.getElementById("selfTypePanel").classList.remove("open");
    document.getElementById("oppTypePanel").classList.remove("open");
  }

  function editRecord(id) {
    const rec = records.find(r=>r.id===id);
    if (!rec) return;
    editingId = id;

    document.getElementById("dateInput").value = rec.date || "";
    document.getElementById("myDeckInput").value = rec.myDeck || "";
    document.getElementById("opponentDeckInput").value = rec.opponentDeck || "";
    document.getElementById("myDeckPreset").value = "";
    document.getElementById("opponentDeckPreset").value = "";
    document.getElementById("typeInput").value = rec.type || "";
    document.getElementById("opponentTypeInput").value = rec.opponentType || "";
    document.getElementById("resultInput").value = rec.result || "win";
    document.getElementById("orderInput").value = rec.order || "first";
    document.getElementById("memoInput").value = rec.memo || "";

    updateSelfPreview();
    updateOpponentPreview();
    updateResultColor();
    document.getElementById("selfTypePanel").classList.remove("open");
    document.getElementById("oppTypePanel").classList.remove("open");

    const btn = document.getElementById("submitButton");
    if (btn) btn.textContent = "記録を更新";
    window.scrollTo({top:0,behavior:"smooth"});
  }

  function deleteRecord(id) {
    if (!confirm("この記録を削除しますか？")) return;
    records = records.filter(r=>r.id!==id);
    saveData();
    clearForm();
    render();
  }

  function clearAll() {
    if (!confirm("すべての記録を削除しますか？")) return;
    records = [];
    saveData();
    clearForm();
    render();
  }

  // ★ 自分／相手のデッキセルを作る（カード画像＋デッキ名＋属性アイコン）
  function createDeckCell(deckName, typeKey, isOpponent) {
    const td = document.createElement("td");
    td.className = "deck-cell";

    const cardSrc = DECK_IMAGE_MAP[deckName || ""];
    if (cardSrc) {
      const cardImg = document.createElement("img");
      cardImg.src = cardSrc;
      cardImg.alt = "";
      cardImg.className = "card-thumb";
      td.appendChild(cardImg);
    }

    const typeSrc = typeIconSrc(typeKey);
    if (typeSrc) {
      const typeImg = document.createElement("img");
      typeImg.src = typeSrc;
      typeImg.alt = "";
      typeImg.className = "type-icon";
      td.appendChild(typeImg);
    }

    const span = document.createElement("span");
    span.textContent = deckName || "";
    td.appendChild(span);

    return td;
  }

  function renderTable() {
    const tbody = document.querySelector("#recordsTable tbody");
    tbody.innerHTML = "";
    if (records.length===0){
      document.getElementById("countText").textContent="0件";
      return;
    }
    const slumpMap = calcSlumpMap();
    const sortedDesc = sortedByDateAsc().slice().reverse();

    sortedDesc.forEach(rec=>{
      const tr = document.createElement("tr");

      const tdDate=document.createElement("td");
      tdDate.textContent = `${rec.battleNumber}戦目  ${formatDate(rec.date)}`;

      // 自分のデッキセル
      const tdMy = createDeckCell(rec.myDeck, rec.type, false);

      // 相手のデッキセル
      const tdOpp = createDeckCell(rec.opponentDeck, rec.opponentType, true);

      const tdRes=document.createElement("td");
      const spanR=document.createElement("span");
      spanR.textContent = resultLabel(rec.result);
      spanR.className = resultClass(rec.result);
      const spanO=document.createElement("span");
      spanO.textContent = orderLabel(rec.order);
      spanO.className = "tag-order";
      tdRes.appendChild(spanR);
      tdRes.appendChild(spanO);

      const tdSlump=document.createElement("td");
      const v = slumpMap[rec.id] ?? 0;
      const sign = v>0?"+":"";
      tdSlump.textContent = sign+v;
      tdSlump.className = v>0?"slump-plus":v<0?"slump-minus":"slump-zero";

      const tdMemo=document.createElement("td");
      tdMemo.textContent = rec.memo || "";

      const tdAct=document.createElement("td");
      const editBtn=document.createElement("button");
      editBtn.textContent="編集";
      editBtn.className="btn-sub";
      editBtn.style.fontSize="11px";
      editBtn.style.marginRight="4px";
      editBtn.onclick=()=>editRecord(rec.id);

      const delBtn=document.createElement("button");
      delBtn.textContent="削除";
      delBtn.className="btn-sub";
      delBtn.style.fontSize="11px";
      delBtn.onclick=()=>deleteRecord(rec.id);

      tdAct.appendChild(editBtn);
      tdAct.appendChild(delBtn);

      tr.appendChild(tdDate);
      tr.appendChild(tdMy);
      tr.appendChild(tdOpp);
      tr.appendChild(tdRes);
      tr.appendChild(tdSlump);
      tr.appendChild(tdMemo);
      tr.appendChild(tdAct);

      tbody.appendChild(tr);
    });

    document.getElementById("countText").textContent=`${records.length}件`;
  }

  function renderDeckStats() {
    const tbody=document.querySelector("#deckStatsTable tbody");
    tbody.innerHTML="";
    if (records.length===0) return;

    const stats={};
    records.forEach(r=>{
      const key=r.myDeck||"（名称未入力）";
      if (!stats[key]) stats[key]={win:0,lose:0,draw:0,total:0};
      stats[key].total++;
      if (r.result==="win") stats[key].win++;
      else if (r.result==="lose") stats[key].lose++;
      else if (r.result==="draw") stats[key].draw++;
    });

    Object.keys(stats).sort().forEach(name=>{
      const s=stats[name];
      const battle=s.win+s.lose;
      const rate=battle===0?0:(s.win/battle*100);

      const tr=document.createElement("tr");
      const tdName=document.createElement("td");
      tdName.textContent=name;
      const tdTotal=document.createElement("td");
      tdTotal.textContent=s.total;
      const tdW=document.createElement("td");
      tdW.textContent=s.win;
      const tdL=document.createElement("td");
      tdL.textContent=s.lose;
      const tdD=document.createElement("td");
      tdD.textContent=s.draw;
      const tdRate=document.createElement("td");
      tdRate.textContent=rate.toFixed(1)+"%";

      let color="#6b7280";
      if (battle>0){
        if (rate>=55) color="#2563eb";
        else if (rate<=45) color="#dc2626";
      }
      tdRate.style.color=color;

      tr.appendChild(tdName);
      tr.appendChild(tdTotal);
      tr.appendChild(tdW);
      tr.appendChild(tdL);
      tr.appendChild(tdD);
      tr.appendChild(tdRate);
      tbody.appendChild(tr);
    });
  }

  function typeHeaderHTML(key){
    const src=typeIconSrc(key);
    const label=TYPE_LABEL[key]||"";
    return `<img src="${src}" class="type-icon" alt="">${label}`;
  }

  function renderTypeMatrix(){
    const table=document.getElementById("typeMatrixTable");
    if (!table) return;

    if (records.length===0){
      table.innerHTML="<tbody><tr><td class='muted'>まだデータがありません</td></tr></tbody>";
      return;
    }

    const matrix={};
    records.forEach(r=>{
      const self=r.type;
      const opp=r.opponentType;
      if (!self || !opp) return;
      const key=self+"|"+opp;
      if (!matrix[key]) matrix[key]={win:0,lose:0,draw:0,total:0};
      matrix[key].total++;
      if (r.result==="win") matrix[key].win++;
      else if (r.result==="lose") matrix[key].lose++;
      else if (r.result==="draw") matrix[key].draw++;
    });

    let html="<thead><tr><th>自＼相</th>";
    TYPE_KEYS.forEach(k=>{ html+=`<th>${typeHeaderHTML(k)}</th>`; });
    html+="</tr></thead><tbody>";

    TYPE_KEYS.forEach(selfKey=>{
      html+="<tr>";
      html+=`<th>${typeHeaderHTML(selfKey)}</th>`;
      TYPE_KEYS.forEach(oppKey=>{
        const key=selfKey+"|"+oppKey;
        const cell=matrix[key];
        if (!cell || cell.total===0){
          html+="<td>－</td>";
        } else {
          const battle=cell.win+cell.lose;
          const rate=battle===0?0:(cell.win/battle*100);
          html+=`<td>${rate.toFixed(1)}%<br>(${cell.win}/${cell.total})</td>`;
        }
      });
      html+="</tr>";
    });
    html+="</tbody>";
    table.innerHTML=html;
  }

  function setRateColor(id, rate, hasBattle) {
    const el=document.getElementById(id);
    if (!el) return;
    if (!hasBattle){
      el.style.color="#6b7280";
      return;
    }
    el.style.color = rate>=50 ? "#2563eb" : "#dc2626";
  }

  function renderStats() {
    const wins=records.filter(r=>r.result==="win").length;
    const loses=records.filter(r=>r.result==="lose").length;
    const draws=records.filter(r=>r.result==="draw").length;
    const total=records.length;
    const battle=wins+loses;
    const winRate=battle===0?0:(wins/battle*100);

    document.getElementById("totalText").textContent=`${total}戦`;
    document.getElementById("wlText").textContent=`勝${wins} / 負${loses} / 分${draws}`;
    document.getElementById("winRateText").textContent=winRate.toFixed(1)+"%";
    setRateColor("winRateText", winRate, battle>0);

    const first=records.filter(r=>r.order==="first");
    const second=records.filter(r=>r.order==="second");
    const fW=first.filter(r=>r.result==="win").length;
    const fL=first.filter(r=>r.result==="lose").length;
    const sW=second.filter(r=>r.result==="win").length;
    const sL=second.filter(r=>r.result==="lose").length;
    const fTotal=fW+fL;
    const sTotal=sW+sL;
    const fRate=fTotal===0?0:(fW/fTotal*100);
    const sRate=sTotal===0?0:(sW/sTotal*100);

    document.getElementById("firstRateText").textContent=fRate.toFixed(1)+"%";
    document.getElementById("firstDetailText").textContent=`${fW}勝 ${fL}敗`;
    document.getElementById("secondRateText").textContent=sRate.toFixed(1)+"%";
    document.getElementById("secondDetailText").textContent=`${sW}勝 ${sL}敗`;

    setRateColor("firstRateText", fRate, fTotal>0);
    setRateColor("secondRateText", sRate, sTotal>0);
  }

  function render() {
    renderTable();
    renderStats();
    renderWinRateGraph();
    renderSlumpGraph();
    renderDeckStats();
    renderTypeMatrix();
    renderDeckPresets();
  }

  function updateResultColor() {
    const sel=document.getElementById("resultInput");
    if (!sel) return;
    let color="#6b7280";
    if (sel.value==="win") color="#1d4ed8";
    else if (sel.value==="lose") color="#b91c1c";
    sel.style.color=color;
  }

  // ★ バックアップ（JSONファイルをダウンロード）
  function backupData() {
    if (!records.length) {
      alert("バックアップするデータがありません。");
      return;
    }
    const blob = new Blob([JSON.stringify(records, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const today = new Date().toISOString().slice(0,10);
    a.href = url;
    a.download = "pokepoke-backup-" + today + ".json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // ★ 復元（JSON を読み込んで records に上書き）
  function restoreData() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "application/json";
    input.onchange = (e)=>{
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev)=>{
        try {
          const data = JSON.parse(ev.target.result);
          if (!Array.isArray(data)) throw new Error("not array");
          records = data;
          saveData();
          clearForm();
          render();
          alert("復元しました。");
        } catch (err) {
          alert("復元に失敗しました。ファイルを確認してください。");
        }
      };
      reader.readAsText(file);
    };
    input.click();
  }

  loadData();
  window.addEventListener("load",()=>{
    const today=new Date().toISOString().slice(0,10);
    const dateInput=document.getElementById("dateInput");
    if (dateInput) dateInput.value=today;
    updateSelfPreview();
    updateOpponentPreview();
    updateResultColor();
    render();
  });
</script>
</body>
</html>
