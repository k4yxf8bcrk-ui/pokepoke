<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ポケポケ 勝敗記録</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- iPhoneホーム画面アイコン（icons/app-icon.png を用意するとアイコン付きになる） -->
  <link rel="apple-touch-icon" href="icons/app-icon.png">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
      margin: 0;
      padding: 0;
      background: #f4f6fb;
    }
    header {
      background: #2563eb;
      color: white;
      padding: 12px 16px;
      font-size: 20px;
      font-weight: bold;
    }
    main {
      padding: 12px 16px 40px;
      max-width: 900px;
      margin: 0 auto;
    }
    .card {
      background: white;
      border-radius: 12px;
      padding: 12px 14px;
      margin-bottom: 12px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .card h2 {
      margin: 0 0 6px;
      font-size: 16px;
    }
    .card small {
      color: #6b7280;
    }
    label {
      font-size: 13px;
      display: block;
      margin: 6px 0 2px;
    }
    input[type="text"],
    input[type="date"],
    textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-size: 13px;
    }
    textarea {
      min-height: 50px;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 13px;
      cursor: pointer;
    }
    .btn-main {
      background: #2563eb;
      color: white;
    }
    .btn-sub {
      background: #e5e7eb;
      color: #374151;
    }
    .row {
      display: flex;
      gap: 8px;
    }
    .row > div {
      flex: 1;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    th, td {
      border-bottom: 1px solid #e5e7eb;
      padding: 4px 6px;
      text-align: left;
    }
    th {
      background: #f3f4f6;
    }
    .tag-win {
      color: #1d4ed8;
      font-weight: bold;
    }
    .tag-lose {
      color: #b91c1c;
      font-weight: bold;
    }
    .tag-draw {
      color: #6b7280;
      font-weight: bold;
    }
    .tag-order {
      font-size: 11px;
      padding: 1px 6px;
      border-radius: 999px;
      background: #e5e7eb;
      margin-left: 4px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px;
      font-size: 13px;
    }
    .stat-box {
      padding: 6px 8px;
      border-radius: 10px;
      background: #eff6ff;
    }
    .stat-title {
      font-size: 12px;
      color: #4b5563;
    }
    .stat-main {
      font-size: 16px;
      font-weight: bold;
    }
    .stat-sub {
      font-size: 12px;
      color: #6b7280;
    }
    .muted {
      color: #6b7280;
      font-size: 12px;
    }
    .type-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      object-fit: cover;
      margin-right: 4px;
      vertical-align: middle;
    }
    .type-preview {
      margin-top: 4px;
      font-size: 12px;
      color: #4b5563;
      display: flex;
      align-items: center;
      min-height: 22px;
      cursor: pointer;
    }
    .type-preview span {
      margin-left: 4px;
      font-size: 11px;
      color: #6b7280;
    }
    .type-picker {
      position: relative;
      margin-top: 2px;
    }
    .type-panel {
      position: relative;
      margin-top: 4px;
      padding: 6px;
      border-radius: 10px;
      background: #f3f4ff;
      display: none;
      flex-wrap: wrap;
      gap: 6px;
    }
    .type-panel.open {
      display: flex;
    }
    .type-btn {
      border-radius: 999px;
      padding: 4px;
      background: white;
      border: 1px solid #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
    }
    .type-btn img {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      object-fit: cover;
    }
    canvas {
      width: 100%;
      height: 200px;
      display: block;
    }
    /* スランプ値の色 */
    .slump-plus {
      color: #2563eb;
      font-weight: bold;
    }
    .slump-minus {
      color: #dc2626;
      font-weight: bold;
    }
    .slump-zero {
      color: #6b7280;
    }
    /* 属性マトリクス用 */
    #typeMatrixTable th,
    #typeMatrixTable td {
      text-align: center;
      font-size: 11px;
      padding: 4px;
    }
    #deckStatsTable th,
    #deckStatsTable td {
      font-size: 12px;
    }
  </style>
</head>
<body>
<header>
  ポケポケ 勝敗記録（Web版）
</header>

<main>
  <!-- 入力フォーム -->
  <section class="card">
    <h2>対戦を記録</h2>
    <div class="row">
      <div>
        <label>日付</label>
        <input type="date" id="dateInput">
      </div>
      <div>
        <label>自分のデッキ</label>
        <input type="text" id="myDeckInput" placeholder="例）エビワラー" />
      </div>
    </div>

    <label>相手のデッキ</label>
    <input type="text" id="opponentDeckInput" placeholder="例）水デッキ" />

    <div class="row">
      <div>
        <label>自分の属性</label>
        <input type="hidden" id="typeInput">
        <div class="type-picker">
          <div id="selfTypePreview" class="type-preview" onclick="toggleTypePanel('self')">
            <span>タップして属性を選択</span>
          </div>
          <div id="selfTypePanel" class="type-panel">
            <!-- 公式順：炎,水,草,雷,超,悪,闘,鋼,無色 -->
            <button type="button" class="type-btn" onclick="selectType('self','fire')">
              <img src="icons/fire.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','water')">
              <img src="icons/water.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','grass')">
              <img src="icons/grass.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','lightning')">
              <img src="icons/lightning.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','psychic')">
              <img src="icons/psychic.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','darkness')">
              <img src="icons/darkness.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','fighting')">
              <img src="icons/fighting.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','metal')">
              <img src="icons/metal.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','colorless')">
              <img src="icons/colorless.png" alt="">
            </button>
          </div>
        </div>
      </div>

      <div>
        <label>相手の属性</label>
        <input type="hidden" id="opponentTypeInput">
        <div class="type-picker">
          <div id="oppTypePreview" class="type-preview" onclick="toggleTypePanel('opp')">
            <span>タップして属性を選択</span>
          </div>
          <div id="oppTypePanel" class="type-panel">
            <button type="button" class="type-btn" onclick="selectType('opp','fire')">
              <img src="icons/fire.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','water')">
              <img src="icons/water.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','grass')">
              <img src="icons/grass.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','lightning')">
              <img src="icons/lightning.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','psychic')">
              <img src="icons/psychic.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','darkness')">
              <img src="icons/darkness.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','fighting')">
              <img src="icons/fighting.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','metal')">
              <img src="icons/metal.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','colorless')">
              <img src="icons/colorless.png" alt="">
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div>
        <label>結果</label>
        <select id="resultInput" style="width:100%;padding:6px 8px;border-radius:8px;border:1px solid #d1d5db;font-size:13px;">
          <option value="win">勝ち</option>
          <option value="lose">負け</option>
          <option value="draw">引き分け</option>
        </select>
      </div>
      <div>
        <label>先攻 / 後攻</label>
        <select id="orderInput" style="width:100%;padding:6px 8px;border-radius:8px;border:1px solid #d1d5db;font-size:13px;">
          <option value="first">先攻</option>
          <option value="second">後攻</option>
        </select>
      </div>
    </div>

    <label>メモ</label>
    <textarea id="memoInput" placeholder="例）サイド差2枚で押し切り、事故、じゃんけん負けなど"></textarea>

    <div style="margin-top:8px; display:flex; gap:8px; justify-content:flex-end;">
      <button class="btn-sub" type="button" onclick="clearForm()">リセット</button>
      <button class="btn-main" type="button" onclick="addRecord()">記録を追加</button>
    </div>
    <p class="muted">※ ブラウザの中に自動保存されます（localStorage使用）。</p>
  </section>

  <!-- 成績サマリ -->
  <section class="card">
    <h2>成績サマリー</h2>
    <div class="stats-grid">
      <div class="stat-box">
        <div class="stat-title">トータル</div>
        <div class="stat-main" id="totalText">0戦</div>
        <div class="stat-sub" id="wlText">勝0 / 負0 / 分0</div>
      </div>
      <div class="stat-box">
        <div class="stat-title">総合勝率（引き分け除く）</div>
        <div class="stat-main" id="winRateText">0.0%</div>
        <div class="stat-sub">（勝 / （勝+負））</div>
      </div>
      <div class="stat-box">
        <div class="stat-title">先攻 勝率</div>
        <div class="stat-main" id="firstRateText">0.0%</div>
        <div class="stat-sub" id="firstDetailText">0勝 0敗</div>
      </div>
      <div class="stat-box">
        <div class="stat-title">後攻 勝率</div>
        <div class="stat-main" id="secondRateText">0.0%</div>
        <div class="stat-sub" id="secondDetailText">0勝 0敗</div>
      </div>
    </div>
  </section>

  <!-- 勝率グラフ -->
  <section class="card">
    <h2>勝率の推移</h2>
    <small>勝ち / 負けのみで計算（引き分けは除外）</small>
    <canvas id="winrateCanvas"></canvas>
  </section>

  <!-- スランプグラフ -->
  <section class="card">
    <h2>スランプグラフ</h2>
    <small>勝ち +1 / 負け −1 / 引き分け 0 の累計（古い対戦から順に）</small>
    <canvas id="slumpCanvas"></canvas>
    <small id="slumpInfo" class="muted"></small><br>
    <small id="streakMax" class="muted"></small><br>
    <small id="streakCurrent" class="muted"></small>
  </section>

  <!-- デッキ別戦績 -->
  <section class="card">
    <h2>デッキ別戦績（自分のデッキ）</h2>
    <div style="overflow-x:auto;">
      <table id="deckStatsTable">
        <thead>
          <tr>
            <th>デッキ名</th>
            <th>対戦数</th>
            <th>勝</th>
            <th>負</th>
            <th>分</th>
            <th>勝率</th>
          </tr>
        </thead>
        <tbody>
          <!-- JSで追加 -->
        </tbody>
      </table>
    </div>
  </section>

  <!-- 属性×属性 勝率 -->
  <section class="card">
    <h2>属性 × 属性 勝率</h2>
    <small>行：自分の属性 ／ 列：相手の属性</small>
    <div style="overflow-x:auto;">
      <table id="typeMatrixTable">
        <!-- JSで生成 -->
      </table>
    </div>
  </section>

  <!-- 対戦一覧 -->
  <section class="card">
    <h2>対戦履歴</h2>
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
      <small id="countText">0件</small>
      <button class="btn-sub" type="button" onclick="clearAll()" style="font-size:11px;">全消去</button>
    </div>
    <div style="overflow-x:auto;">
      <table id="recordsTable">
        <thead>
          <tr>
            <th>日付</th>
            <th>自分のデッキ</th>
            <th>相手のデッキ</th>
            <th>結果</th>
            <th>スランプ</th>
            <th>メモ</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          <!-- JSで追加 -->
        </tbody>
      </table>
    </div>
  </section>
</main>

<script>
  // ------------ 定数 ------------
  const TYPE_KEYS = ["fire","water","grass","lightning","psychic","darkness","fighting","metal","colorless"];
  const TYPE_LABEL = {
    fire: "炎",
    water: "水",
    grass: "草",
    lightning: "雷",
    psychic: "超",
    darkness: "悪",
    fighting: "闘",
    metal: "鋼",
    colorless: "無"
  };

  // ------------ データ管理 ------------
  let records = [];

  function loadData() {
    const raw = localStorage.getItem("pokepokeRecords");
    if (raw) {
      try {
        records = JSON.parse(raw);
      } catch (e) {
        records = [];
      }
    }
  }

  function saveData() {
    localStorage.setItem("pokepokeRecords", JSON.stringify(records));
  }

  // ------------ ユーティリティ ------------
  function formatDate(iso) {
    if (!iso) return "";
    const d = new Date(iso);
    if (isNaN(d.getTime())) return iso;
    const y = d.getFullYear();
    const m = ("0" + (d.getMonth() + 1)).slice(-2);
    const day = ("0" + d.getDate()).slice(-2);
    return `${y}/${m}/${day}`;
  }

  function resultLabel(r) {
    if (r === "win") return "勝ち";
    if (r === "lose") return "負け";
    if (r === "draw") return "引き分け";
    return "";
  }

  function orderLabel(o) {
    if (o === "first") return "先攻";
    if (o === "second") return "後攻";
    return "";
  }

  function resultClass(r) {
    if (r === "win") return "tag-win";
    if (r === "lose") return "tag-lose";
    return "tag-draw";
  }

  function typeIconSrc(t) {
    if (!t) return null;
    return "icons/" + t + ".png";
  }

  // ------------ アイコンパネル制御 ------------
  function toggleTypePanel(who) {
    const selfPanel = document.getElementById("selfTypePanel");
    const oppPanel = document.getElementById("oppTypePanel");
    if (who === "self") {
      const open = !selfPanel.classList.contains("open");
      selfPanel.classList.toggle("open", open);
      oppPanel.classList.remove("open");
    } else {
      const open = !oppPanel.classList.contains("open");
      oppPanel.classList.toggle("open", open);
      selfPanel.classList.remove("open");
    }
  }

  function selectType(who, type) {
    if (who === "self") {
      document.getElementById("typeInput").value = type;
      updateSelfPreview();
      document.getElementById("selfTypePanel").classList.remove("open");
    } else {
      document.getElementById("opponentTypeInput").value = type;
      updateOpponentPreview();
      document.getElementById("oppTypePanel").classList.remove("open");
    }
  }

  function updateSelfPreview() {
    const t = document.getElementById("typeInput").value;
    const container = document.getElementById("selfTypePreview");
    container.innerHTML = "";

    if (!t) {
      const span = document.createElement("span");
      span.textContent = "タップして属性を選択";
      container.appendChild(span);
      return;
    }
    const src = typeIconSrc(t);
    if (src) {
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.className = "type-icon";
      container.appendChild(img);
    }
  }

  function updateOpponentPreview() {
    const t = document.getElementById("opponentTypeInput").value;
    const container = document.getElementById("oppTypePreview");
    container.innerHTML = "";

    if (!t) {
      const span = document.createElement("span");
      span.textContent = "タップして属性を選択";
      container.appendChild(span);
      return;
    }

    const src = typeIconSrc(t);
    if (src) {
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.className = "type-icon";
      container.appendChild(img);
    }
  }

  // ------------ スランプ計算 ------------
  function sortedByDateAsc() {
    return records
      .slice()
      .sort((a, b) => {
        const ad = a.date || "";
        const bd = b.date || "";
        if (ad < bd) return -1;
        if (ad > bd) return 1;
        return a.id - b.id;
      });
  }

  function calcSlumpPoints() {
    const sorted = sortedByDateAsc();
    let value = 0;
    const points = [];
    for (const r of sorted) {
      if (r.result === "win") value += 1;
      else if (r.result === "lose") value -= 1;
      points.push(value);
    }
    return points;
  }

  // 各試合のスランプ値（id -> value）
  function calcSlumpMap() {
    const sorted = sortedByDateAsc();
    let value = 0;
    const map = {};
    for (const r of sorted) {
      if (r.result === "win") value += 1;
      else if (r.result === "lose") value -= 1;
      map[r.id] = value;
    }
    return map;
  }

  // 連勝・連敗計算
  function calcStreaks() {
    let maxWin = 0;
    let maxLose = 0;
    let curWin = 0;
    let curLose = 0;

    sortedByDateAsc().forEach(r => {
      if (r.result === "win") {
        curWin++;
        curLose = 0;
        if (curWin > maxWin) maxWin = curWin;
      } else if (r.result === "lose") {
        curLose++;
        curWin = 0;
        if (curLose > maxLose) maxLose = curLose;
      } else {
        curWin = 0;
        curLose = 0;
      }
    });

    return { maxWin, maxLose, curWin, curLose };
  }

  // 勝率グラフ用ポイント（%）
  function calcWinRatePoints() {
    const sorted = sortedByDateAsc();
    let wins = 0;
    let loses = 0;
    const points = [];

    for (const r of sorted) {
      if (r.result === "win") wins++;
      else if (r.result === "lose") loses++;
      const battle = wins + loses;
      const rate = battle === 0 ? 0 : (wins / battle * 100);
      points.push(rate);
    }
    return points;
  }

  // ------------ スランプグラフ描画 ------------
  function renderSlumpGraph() {
    const canvas = document.getElementById("slumpCanvas");
    const info = document.getElementById("slumpInfo");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");

    const rect = canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    canvas.width = width;
    canvas.height = height;

    ctx.clearRect(0, 0, width, height);

    const points = calcSlumpPoints();

    // 連勝・連敗表示
    const st = calcStreaks();
    const maxW = st.maxWin;
    const maxL = st.maxLose;
    const nowW = st.curWin;
    const nowL = st.curLose;

    const streakMaxEl = document.getElementById("streakMax");
    const streakCurrentEl = document.getElementById("streakCurrent");

    if (streakMaxEl) {
      streakMaxEl.textContent = `最高連勝：${maxW}連勝　｜　最高連敗：${maxL}連敗`;
    }
    if (streakCurrentEl) {
      streakCurrentEl.textContent = `現在の連勝：${nowW}連勝　｜　現在の連敗：${nowL}連敗`;
    }

    // スランプ情報ラベル
    if (!points.length) {
      if (info) info.textContent = "まだデータがありません";
      ctx.fillStyle = "#9ca3af";
      ctx.font = "12px -apple-system, BlinkMacSystemFont, sans-serif";
      ctx.fillText("まだデータがありません", 10, height / 2);
      return;
    } else {
      const last = points[points.length - 1];
      const sign = last > 0 ? "+" : "";
      if (info) info.textContent = `現在の累計：${sign}${last}`;
    }

    const maxVal = Math.max(...points, 0);
    const minVal = Math.min(...points, 0);
    const range = Math.max(maxVal - minVal, 1);

    const padding = 24;
    const usableW = width - padding * 2;
    const usableH = height - padding * 2;

    // 背景
    ctx.fillStyle = "#f9fafb";
    ctx.fillRect(padding, padding, usableW, usableH);

    // 横グリッド（4本）
    ctx.strokeStyle = "#e5e7eb";
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    const gridCount = 4;
    for (let i = 0; i <= gridCount; i++) {
      const y = padding + (usableH * i) / gridCount;
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(width - padding, y);
      ctx.stroke();
    }
    ctx.setLineDash([]);

    // 0ライン（太め）
    const zeroY = padding + usableH * (maxVal / range);
    ctx.strokeStyle = "#9ca3af";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, zeroY);
    ctx.lineTo(width - padding, zeroY);
    ctx.stroke();

    // 座標変換
    function pointToXY(idx, v) {
      const ratio = points.length === 1 ? 0.5 : idx / (points.length - 1);
      const x = padding + usableW * ratio;
      const y = padding + usableH * ((maxVal - v) / range);
      return { x, y };
    }

    // 線（区間ごとに色変え）
    ctx.lineWidth = 2;
    for (let i = 1; i < points.length; i++) {
      const v1 = points[i - 1];
      const v2 = points[i];
      const { x: x1, y: y1 } = pointToXY(i - 1, v1);
      const { x: x2, y: y2 } = pointToXY(i, v2);
      const avg = (v1 + v2) / 2;
      ctx.strokeStyle = avg >= 0 ? "#2563eb" : "#dc2626";

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // 点
    for (let i = 0; i < points.length; i++) {
      const v = points[i];
      const { x, y } = pointToXY(i, v);
      const color = v >= 0 ? "#2563eb" : "#dc2626";
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // ------------ 勝率グラフ描画 ------------
  function renderWinRateGraph() {
    const canvas = document.getElementById("winrateCanvas");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");

    const rect = canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    canvas.width = width;
    canvas.height = height;

    ctx.clearRect(0, 0, width, height);

    const points = calcWinRatePoints();
    if (points.length === 0 || points.every(v => v === 0)) {
      ctx.fillStyle = "#9ca3af";
      ctx.font = "12px -apple-system, BlinkMacSystemFont, sans-serif";
      ctx.fillText("勝ち負けの対戦がまだありません", 10, height / 2);
      return;
    }

    const maxVal = Math.max(...points, 100);
    const minVal = 0;
    const range = Math.max(maxVal - minVal, 1);

    const padding = 24;
    const usableW = width - padding * 2;
    const usableH = height - padding * 2;

    // 背景
    ctx.fillStyle = "#f9fafb";
    ctx.fillRect(padding, padding, usableW, usableH);

    // 横グリッド（0,25,50,75,100）
    ctx.strokeStyle = "#e5e7eb";
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    const levels = [0,25,50,75,100];
    ctx.font = "10px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.fillStyle = "#6b7280";
    levels.forEach(lv => {
      const ratio = (lv - minVal) / range;
      const y = padding + usableH * (1 - ratio);
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(width - padding, y);
      ctx.stroke();
      ctx.fillText(lv + "%", 4, y + 3);
    });
    ctx.setLineDash([]);

    // 座標変換
    function pointToXY(idx, v) {
      const ratio = points.length === 1 ? 0.5 : idx / (points.length - 1);
      const x = padding + usableW * ratio;
      const yRatio = (v - minVal) / range;
      const y = padding + usableH * (1 - yRatio);
      return { x, y };
    }

    // 線
    ctx.strokeStyle = "#2563eb";
    ctx.lineWidth = 2;
    ctx.beginPath();
    points.forEach((v, i) => {
      const { x, y } = pointToXY(i, v);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // 点
    ctx.fillStyle = "#2563eb";
    points.forEach((v, i) => {
      const { x, y } = pointToXY(i, v);
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // ------------ 追加／クリア ------------
  function addRecord() {
    const date = document.getElementById("dateInput").value;
    const myDeck = document.getElementById("myDeckInput").value.trim();
    const opponentDeck = document.getElementById("opponentDeckInput").value.trim();
    const type = document.getElementById("typeInput").value;
    const opponentType = document.getElementById("opponentTypeInput").value;
    const result = document.getElementById("resultInput").value;
    const order = document.getElementById("orderInput").value;
    const memo = document.getElementById("memoInput").value.trim();

    if (!myDeck) {
      alert("自分のデッキ名を入力してください。");
      return;
    }

    const rec = {
      id: Date.now(),
      date,
      myDeck,
      opponentDeck,
      type,
      opponentType,
      result,
      order,
      memo
    };

    records.push(rec);
    saveData();
    render();
    clearForm();
  }

  function clearForm() {
    const today = new Date().toISOString().slice(0,10);
    document.getElementById("dateInput").value = today;
    document.getElementById("myDeckInput").value = "";
    document.getElementById("opponentDeckInput").value = "";
    document.getElementById("typeInput").value = "";
    document.getElementById("opponentTypeInput").value = "";
    document.getElementById("resultInput").value = "win";
    document.getElementById("orderInput").value = "first";
    document.getElementById("memoInput").value = "";
    updateSelfPreview();
    updateOpponentPreview();
    document.getElementById("selfTypePanel").classList.remove("open");
    document.getElementById("oppTypePanel").classList.remove("open");
  }

  function deleteRecord(id) {
    if (!confirm("この記録を削除しますか？")) return;
    records = records.filter(r => r.id !== id);
    saveData();
    render();
  }

  function clearAll() {
    if (!confirm("すべての記録を削除しますか？")) return;
    records = [];
    saveData();
    render();
  }

  // ------------ 表示（履歴・デッキ・属性） ------------
  function renderTable() {
    const tbody = document.querySelector("#recordsTable tbody");
    tbody.innerHTML = "";

    if (records.length === 0) {
      document.getElementById("countText").textContent = "0件";
      return;
    }

    // 古い順
    const sortedAsc = sortedByDateAsc();

    // 戦番号＆スランプ値
    const slumpMap = {};
    let slump = 0;
    sortedAsc.forEach((r, i) => {
      if (r.result === "win") slump += 1;
      else if (r.result === "lose") slump -= 1;
      slumpMap[r.id] = slump;
      r.battleNumber = i + 1;
    });

    // 新しい順で表示
    const sortedDesc = sortedAsc.slice().reverse();

    sortedDesc.forEach(rec => {
      const tr = document.createElement("tr");

      const tdDate = document.createElement("td");
      tdDate.textContent = `${rec.battleNumber}戦目  ${formatDate(rec.date)}`;

      // 自分のデッキ（アイコン＋名前）
      const tdMy = document.createElement("td");
      const spanMy = document.createElement("span");
      const mySrc = typeIconSrc(rec.type);
      if (mySrc) {
        const img = document.createElement("img");
        img.src = mySrc;
        img.alt = "";
        img.className = "type-icon";
        spanMy.appendChild(img);
      }
      spanMy.appendChild(document.createTextNode(rec.myDeck || ""));
      tdMy.appendChild(spanMy);

      // 相手のデッキ（アイコン＋名前）
      const tdOpp = document.createElement("td");
      const spanOpp = document.createElement("span");
      const oppSrc = typeIconSrc(rec.opponentType);
      if (oppSrc) {
        const img2 = document.createElement("img");
        img2.src = oppSrc;
        img2.alt = "";
        img2.className = "type-icon";
        spanOpp.appendChild(img2);
      }
      spanOpp.appendChild(document.createTextNode(rec.opponentDeck || ""));
      tdOpp.appendChild(spanOpp);

      const tdRes = document.createElement("td");
      const spanR = document.createElement("span");
      spanR.textContent = resultLabel(rec.result);
      spanR.className = resultClass(rec.result);
      const spanO = document.createElement("span");
      spanO.textContent = orderLabel(rec.order);
      spanO.className = "tag-order";
      tdRes.appendChild(spanR);
      tdRes.appendChild(spanO);

      // スランプ値
      const tdSlump = document.createElement("td");
      const v = slumpMap[rec.id] ?? 0;
      const sign = v > 0 ? "+" : "";
      tdSlump.textContent = sign + v;
      tdSlump.className =
        v > 0 ? "slump-plus" :
        v < 0 ? "slump-minus" :
        "slump-zero";

      const tdMemo = document.createElement("td");
      tdMemo.textContent = rec.memo;

      const tdDel = document.createElement("td");
      const btn = document.createElement("button");
      btn.textContent = "削除";
      btn.className = "btn-sub";
      btn.style.fontSize = "11px";
      btn.onclick = () => deleteRecord(rec.id);
      tdDel.appendChild(btn);

      tr.appendChild(tdDate);
      tr.appendChild(tdMy);
      tr.appendChild(tdOpp);
      tr.appendChild(tdRes);
      tr.appendChild(tdSlump);
      tr.appendChild(tdMemo);
      tr.appendChild(tdDel);

      tbody.appendChild(tr);
    });

    document.getElementById("countText").textContent = `${records.length}件`;
  }

  function renderDeckStats() {
    const tbody = document.querySelector("#deckStatsTable tbody");
    tbody.innerHTML = "";

    if (records.length === 0) return;

    const stats = {};
    records.forEach(r => {
      const key = r.myDeck || "（名称未入力）";
      if (!stats[key]) {
        stats[key] = { win:0, lose:0, draw:0, total:0 };
      }
      stats[key].total++;
      if (r.result === "win") stats[key].win++;
      else if (r.result === "lose") stats[key].lose++;
      else if (r.result === "draw") stats[key].draw++;
    });

    Object.keys(stats)
      .sort()
      .forEach(name => {
        const s = stats[name];
        const battle = s.win + s.lose;
        const rate = battle === 0 ? 0 : s.win / battle * 100;

        const tr = document.createElement("tr");
        const tdName = document.createElement("td");
        tdName.textContent = name;

        const tdTotal = document.createElement("td");
        tdTotal.textContent = s.total;

        const tdW = document.createElement("td");
        tdW.textContent = s.win;

        const tdL = document.createElement("td");
        tdL.textContent = s.lose;

        const tdD = document.createElement("td");
        tdD.textContent = s.draw;

        const tdRate = document.createElement("td");
        tdRate.textContent = rate.toFixed(1) + "%";

        tr.appendChild(tdName);
        tr.appendChild(tdTotal);
        tr.appendChild(tdW);
        tr.appendChild(tdL);
        tr.appendChild(tdD);
        tr.appendChild(tdRate);

        tbody.appendChild(tr);
      });
  }

  function typeHeaderHTML(key) {
    const src = typeIconSrc(key);
    const label = TYPE_LABEL[key] || "";
    return `<img src="${src}" class="type-icon" alt="">${label}`;
  }

  function renderTypeMatrix() {
    const table = document.getElementById("typeMatrixTable");
    if (!table) return;

    if (records.length === 0) {
      table.innerHTML = "<tbody><tr><td class='muted'>まだデータがありません</td></tr></tbody>";
      return;
    }

    const matrix = {};
    records.forEach(r => {
      const self = r.type;
      const opp = r.opponentType;
      if (!self || !opp) return;
      const key = self + "|" + opp;
      if (!matrix[key]) {
        matrix[key] = { win:0, lose:0, draw:0, total:0 };
      }
      matrix[key].total++;
      if (r.result === "win") matrix[key].win++;
      else if (r.result === "lose") matrix[key].lose++;
      else if (r.result === "draw") matrix[key].draw++;
    });

    let html = "<thead><tr><th>自＼相</th>";
    TYPE_KEYS.forEach(k => {
      html += `<th>${typeHeaderHTML(k)}</th>`;
    });
    html += "</tr></thead><tbody>";

    TYPE_KEYS.forEach(selfKey => {
      html += "<tr>";
      html += `<th>${typeHeaderHTML(selfKey)}</th>`;
      TYPE_KEYS.forEach(oppKey => {
        const key = selfKey + "|" + oppKey;
        const cell = matrix[key];
        if (!cell || cell.total === 0) {
          html += "<td>－</td>";
        } else {
          const battle = cell.win + cell.lose;
          const rate = battle === 0 ? 0 : (cell.win / battle * 100);
          html += `<td>${rate.toFixed(1)}%<br>(${cell.win}/${cell.total})</td>`;
        }
      });
      html += "</tr>";
    });

    html += "</tbody>";
    table.innerHTML = html;
  }

  function renderStats() {
    const wins = records.filter(r => r.result === "win").length;
    const loses = records.filter(r => r.result === "lose").length;
    const draws = records.filter(r => r.result === "draw").length;
    const total = records.length;

    const battle = wins + loses;
    const winRate = battle === 0 ? 0 : wins / battle * 100;

    document.getElementById("totalText").textContent = `${total}戦`;
    document.getElementById("wlText").textContent = `勝${wins} / 負${loses} / 分${draws}`;
    document.getElementById("winRateText").textContent = winRate.toFixed(1) + "%";

    const first = records.filter(r => r.order === "first");
    const second = records.filter(r => r.order === "second");

    const fW = first.filter(r => r.result === "win").length;
    const fL = first.filter(r => r.result === "lose").length;
    const sW = second.filter(r => r.result === "win").length;
    const sL = second.filter(r => r.result === "lose").length;

    const fTotal = fW + fL;
    const sTotal = sW + sL;

    const fRate = fTotal === 0 ? 0 : fW / fTotal * 100;
    const sRate = sTotal === 0 ? 0 : sW / sTotal * 100;

    document.getElementById("firstRateText").textContent = fRate.toFixed(1) + "%";
    document.getElementById("firstDetailText").textContent = `${fW}勝 ${fL}敗`;

    document.getElementById("secondRateText").textContent = sRate.toFixed(1) + "%";
    document.getElementById("secondDetailText").textContent = `${sW}勝 ${sL}敗`;
  }

  function render() {
    renderTable();
    renderStats();
    renderWinRateGraph();
    renderSlumpGraph();
    renderDeckStats();
    renderTypeMatrix();
  }

  // 初期化
  loadData();
  window.addEventListener("load", () => {
    const today = new Date().toISOString().slice(0,10);
    const dateInput = document.getElementById("dateInput");
    if (dateInput) dateInput.value = today;
    updateSelfPreview();
    updateOpponentPreview();
    render();
  });
</script>
</body>
</html>
