<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ポケポケ 勝敗記録</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="apple-touch-icon" href="icons/app-icon.png">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;
      margin: 0;
      padding: 0;
      background: #f4f6fb;
    }
    header {
      background: #2563eb;
      color: white;
      padding: 12px 16px;
      font-size: 20px;
      font-weight: bold;
    }
    main {
      padding: 12px 16px 40px;
      max-width: 900px;
      margin: 0 auto;
    }
    .card {
      background: white;
      border-radius: 12px;
      padding: 12px 14px;
      margin-bottom: 12px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .card h2 {
      margin: 0 0 6px;
      font-size: 16px;
    }
    .card small {
      color: #6b7280;
    }
    label {
      font-size: 13px;
      display: block;
      margin: 6px 0 2px;
    }
    input[type="text"],
    input[type="date"],
    textarea,
    select {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-size: 13px;
      background: #ffffff;
    }
    textarea {
      min-height: 50px;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      font-size: 13px;
      cursor: pointer;
    }
    .btn-main {
      background: #2563eb;
      color: white;
    }
    .btn-sub {
      background: #e5e7eb;
      color: #374151;
    }
    .row {
      display: flex;
      gap: 8px;
    }
    .row > div {
      flex: 1;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    th, td {
      border-bottom: 1px solid #e5e7eb;
      padding: 4px 6px;
      text-align: left;
    }
    th {
      background: #f3f4f6;
    }
    .tag-win {
      color: #1d4ed8;
      font-weight: bold;
    }
    .tag-lose {
      color: #b91c1c;
      font-weight: bold;
    }
    .tag-draw {
      color: #6b7280;
      font-weight: bold;
    }
    .tag-order {
      font-size: 11px;
      padding: 1px 6px;
      border-radius: 999px;
      background: #e5e7eb;
      margin-left: 4px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px;
      font-size: 13px;
    }
    .stat-box {
      padding: 6px 8px;
      border-radius: 10px;
      background: #eff6ff;
    }
    .stat-title {
      font-size: 12px;
      color: #4b5563;
    }
    .stat-main {
      font-size: 16px;
      font-weight: bold;
    }
    .stat-sub {
      font-size: 12px;
      color: #6b7280;
    }
    .muted {
      color: #6b7280;
      font-size: 12px;
    }
    .type-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      object-fit: cover;
      margin-right: 4px;
      vertical-align: middle;
    }
    /* デッキカード画像（サムネ） */
    .deck-card-icon {
      width: 32px;
      height: 44px;
      object-fit: cover;
      border-radius: 4px;
      margin-right: 4px;
      vertical-align: middle;
    }
    .type-preview {
      margin-top: 4px;
      font-size: 12px;
      color: #4b5563;
      display: flex;
      align-items: center;
      min-height: 22px;
      cursor: pointer;
    }
    .type-preview span {
      margin-left: 4px;
      font-size: 11px;
      color: #6b7280;
    }
    .type-picker {
      position: relative;
      margin-top: 2px;
    }
    .type-panel {
      position: relative;
      margin-top: 4px;
      padding: 6px;
      border-radius: 10px;
      background: #f3f4ff;
      display: none;
      flex-wrap: wrap;
      gap: 6px;
    }
    .type-panel.open {
      display: flex;
    }
    .type-btn {
      border-radius: 999px;
      padding: 4px;
      background: white;
      border: 1px solid #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
    }
    .type-btn img {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      object-fit: cover;
    }
    canvas {
      width: 100%;
      height: 200px;
      display: block;
    }
    /* スランプ値の色 */
    .slump-plus {
      color: #2563eb;
      font-weight: bold;
    }
    .slump-minus {
      color: #dc2626;
      font-weight: bold;
    }
    .slump-zero {
      color: #6b7280;
    }
    /* 属性マトリクス用 */
    #typeMatrixTable th,
    #typeMatrixTable td {
      text-align: center;
      font-size: 11px;
      padding: 4px;
    }
    #deckStatsTable th,
    #deckStatsTable td {
      font-size: 12px;
    }
  </style>
</head>
<body>
<header>
  ポケポケ 勝敗記録（Web版）
</header>

<main>
  <!-- 入力フォーム -->
  <section class="card">
    <h2>対戦を記録</h2>
    <div class="row">
      <div>
        <label>日付</label>
        <input type="date" id="dateInput">
      </div>
      <div>
        <label>自分のデッキ</label>
        <select id="myDeckPreset" onchange="applyDeckPreset('my')">
          <option value="">▼ 履歴から選択（任意）</option>
        </select>
        <input type="text" id="myDeckInput" placeholder="例）エビワラー" />
      </div>
    </div>

    <label>相手のデッキ</label>
    <select id="opponentDeckPreset" onchange="applyDeckPreset('opp')">
      <option value="">▼ 履歴から選択（任意）</option>
    </select>
    <input type="text" id="opponentDeckInput" placeholder="例）水デッキ" />

    <div class="row">
      <div>
        <label>自分の属性</label>
        <input type="hidden" id="typeInput">
        <div class="type-picker">
          <div id="selfTypePreview" class="type-preview" onclick="toggleTypePanel('self')">
            <span>タップして属性を選択</span>
          </div>
          <div id="selfTypePanel" class="type-panel">
            <button type="button" class="type-btn" onclick="selectType('self','fire')">
              <img src="icons/fire.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','water')">
              <img src="icons/water.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','grass')">
              <img src="icons/grass.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','lightning')">
              <img src="icons/lightning.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','psychic')">
              <img src="icons/psychic.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','darkness')">
              <img src="icons/darkness.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','fighting')">
              <img src="icons/fighting.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','metal')">
              <img src="icons/metal.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('self','colorless')">
              <img src="icons/colorless.png" alt="">
            </button>
          </div>
        </div>
      </div>

      <div>
        <label>相手の属性</label>
        <input type="hidden" id="opponentTypeInput">
        <div class="type-picker">
          <div id="oppTypePreview" class="type-preview" onclick="toggleTypePanel('opp')">
            <span>タップして属性を選択</span>
          </div>
          <div id="oppTypePanel" class="type-panel">
            <button type="button" class="type-btn" onclick="selectType('opp','fire')">
              <img src="icons/fire.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','water')">
              <img src="icons/water.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','grass')">
              <img src="icons/grass.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','lightning')">
              <img src="icons/lightning.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','psychic')">
              <img src="icons/psychic.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','darkness')">
              <img src="icons/darkness.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','fighting')">
              <img src="icons/fighting.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','metal')">
              <img src="icons/metal.png" alt="">
            </button>
            <button type="button" class="type-btn" onclick="selectType('opp','colorless')">
              <img src="icons/colorless.png" alt="">
            </button>
          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div>
        <label>結果</label>
        <select id="resultInput" onchange="updateResultColor()">
          <option value="win">勝ち</option>
          <option value="lose">負け</option>
          <option value="draw">引き分け</option>
        </select>
      </div>
      <div>
        <label>先攻 / 後攻</label>
        <select id="orderInput">
          <option value="first">先攻</option>
          <option value="second">後攻</option>
        </select>
      </div>
    </div>

    <label>メモ</label>
    <textarea id="memoInput" placeholder="例）サイド差2枚で押し切り、事故、じゃんけん負けなど"></textarea>

    <div style="margin-top:8px; display:flex; gap:8px; justify-content:flex-end;">
      <button class="btn-sub" type="button" onclick="clearForm()">リセット</button>
      <button id="submitButton" class="btn-main" type="button" onclick="addRecord()">記録を追加</button>
    </div>
    <p class="muted">※ ブラウザの中に自動保存されます（localStorage使用）。</p>

    <!-- AI予想ブロック -->
    <div id="aiArea" style="margin-top:12px; padding:8px 10px; border-radius:10px; background:#eff6ff;">
      <div style="font-size:13px; font-weight:bold; margin-bottom:4px;">AI予想</div>
      <div id="aiPredictionText" class="muted" style="margin-bottom:4px;">
        条件を入力すると予想が表示されます。
      </div>
      <div style="height:8px; background:#e5e7eb; border-radius:999px; overflow:hidden;">
        <div id="aiPredictionBar" style="height:8px; width:0%; border-radius:999px;"></div>
      </div>
    </div>
  </section>

  <!-- 成績サマリ -->
  <section class="card">
    <h2>成績サマリー</h2>
    <div class="stats-grid">
      <div class="stat-box">
        <div class="stat-title">トータル</div>
        <div class="stat-main" id="totalText">0戦</div>
        <div class="stat-sub" id="wlText">勝0 / 負0 / 分0</div>
      </div>
      <div class="stat-box">
        <div class="stat-title">総合勝率（引き分け除く）</div>
        <div class="stat-main" id="winRateText">0.0%</div>
        <div class="stat-sub">（勝 / （勝+負））</div>
      </div>
      <div class="stat-box">
        <div class="stat-title">先攻 勝率</div>
        <div class="stat-main" id="firstRateText">0.0%</div>
        <div class="stat-sub" id="firstDetailText">0勝 0敗</div>
      </div>
      <div class="stat-box">
        <div class="stat-title">後攻 勝率</div>
        <div class="stat-main" id="secondRateText">0.0%</div>
        <div class="stat-sub" id="secondDetailText">0勝 0敗</div>
      </div>
    </div>
  </section>

  <!-- 勝率グラフ -->
  <section class="card">
    <h2>勝率の推移</h2>
    <small>勝ち / 負けのみで計算（引き分けは除外）｜下の数字は「何戦目」｜50％ライン濃い線：上＝青／下＝赤</small>
    <canvas id="winrateCanvas"></canvas>
  </section>

  <!-- スランプグラフ -->
  <section class="card">
    <h2>スランプグラフ</h2>
    <small>勝ち +1 / 負け −1 / 引き分け 0 の累計（古い対戦から順に）｜左に累計ポイント｜下の数字は「何戦目」</small>
    <canvas id="slumpCanvas"></canvas>
    <small id="slumpInfo" class="muted"></small><br>
    <small class="muted">
      最高連勝：<span id="maxWinText">0連勝</span>　｜　
      最高連敗：<span id="maxLoseText">0連敗</span>
    </small><br>
    <small class="muted">
      現在の連勝：<span id="curWinText">0連勝</span>　｜　
      現在の連敗：<span id="curLoseText">0連敗</span>
    </small>
  </section>

  <!-- デッキ別戦績 -->
  <section class="card">
    <h2>デッキ別戦績（自分のデッキ）</h2>
    <div style="overflow-x:auto;">
      <table id="deckStatsTable">
        <thead>
          <tr>
            <th>デッキ名</th>
            <th>対戦数</th>
            <th>勝</th>
            <th>負</th>
            <th>分</th>
            <th>勝率</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- 属性×属性 勝率 -->
  <section class="card">
    <h2>属性 × 属性 勝率</h2>
    <small>行：自分の属性 ／ 列：相手の属性</small>
    <div style="overflow-x:auto;">
      <table id="typeMatrixTable"></table>
    </div>
  </section>

  <!-- 対戦一覧 -->
  <section class="card">
    <h2>対戦履歴</h2>
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
      <small id="countText">0件</small>
      <div style="display:flex; gap:4px;">
        <button class="btn-sub" type="button" onclick="exportBackup()" style="font-size:11px;">バックアップ</button>
        <button class="btn-sub" type="button" onclick="triggerImport()" style="font-size:11px;">復元</button>
        <button class="btn-sub" type="button" onclick="clearAll()" style="font-size:11px;">全消去</button>
      </div>
    </div>
    <input type="file" id="importFile" accept="application/json" style="display:none" onchange="importBackup(event)">

    <div style="overflow-x:auto;">
      <table id="recordsTable">
        <thead>
          <tr>
            <th>日付</th>
            <th>自分のデッキ</th>
            <th>相手のデッキ</th>
            <th>結果</th>
            <th>スランプ</th>
            <th>メモ</th>
            <th></th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>
</main>

<script>
  const TYPE_KEYS = ["fire","water","grass","lightning","psychic","darkness","fighting","metal","colorless"];
  const TYPE_LABEL = {
    fire: "炎", water: "水", grass: "草",
    lightning: "雷", psychic: "超", darkness: "悪",
    fighting: "闘", metal: "鋼", colorless: "無"
  };

  // ★ デッキ名 → カード画像ファイルの対応表（自由に追加OK）
  const DECK_IMAGE_MAP = {
    "エビワラー": "cards/ebihit.png",
    "水デッキ": "cards/water_deck.png",
    "雷デッキ": "cards/lightning_deck.png"
    // ここに「デッキ名: 画像パス」を追加していく
    // 例: "ミライドン": "cards/miraidon.png"
  };

  let records = [];
  let editingId = null;

  function loadData() {
    const raw = localStorage.getItem("pokepokeRecords");
    if (raw) {
      try { records = JSON.parse(raw); } catch(e) { records = []; }
    }
  }
  function saveData() {
    localStorage.setItem("pokepokeRecords", JSON.stringify(records));
  }

  function formatDate(iso) {
    if (!iso) return "";
    const d = new Date(iso);
    if (isNaN(d.getTime())) return iso;
    const y = d.getFullYear();
    const m = ("0"+(d.getMonth()+1)).slice(-2);
    const day = ("0"+d.getDate()).slice(-2);
    return `${y}/${m}/${day}`;
  }
  function resultLabel(r) {
    if (r === "win") return "勝ち";
    if (r === "lose") return "負け";
    if (r === "draw") return "引き分け";
    return "";
  }
  function orderLabel(o) {
    if (o === "first") return "先攻";
    if (o === "second") return "後攻";
    return "";
  }
  function resultClass(r) {
    if (r === "win") return "tag-win";
    if (r === "lose") return "tag-lose";
    return "tag-draw";
  }
  function typeIconSrc(t) {
    if (!t) return null;
    return "icons/" + t + ".png";
  }
  // デッキ → カード画像
  function deckCardSrc(deckName) {
    if (!deckName) return null;
    return DECK_IMAGE_MAP[deckName] || null;
  }

  function applyDeckPreset(which) {
    if (which === "my") {
      const val = document.getElementById("myDeckPreset").value;
      if (val) document.getElementById("myDeckInput").value = val;
    } else {
      const val = document.getElementById("opponentDeckPreset").value;
      if (val) document.getElementById("opponentDeckInput").value = val;
    }
    updateAIPrediction();
  }

  function renderDeckPresets() {
    const mySel = document.getElementById("myDeckPreset");
    const oppSel = document.getElementById("opponentDeckPreset");
    if (!mySel || !oppSel) return;

    const mySet = new Set();
    const oppSet = new Set();
    records.forEach(r => {
      if (r.myDeck && r.myDeck.trim()) mySet.add(r.myDeck.trim());
      if (r.opponentDeck && r.opponentDeck.trim()) oppSet.add(r.opponentDeck.trim());
    });

    function fillSelect(sel, set, ph) {
      sel.innerHTML = "";
      const o0 = document.createElement("option");
      o0.value = "";
      o0.textContent = ph;
      sel.appendChild(o0);
      Array.from(set).sort().forEach(name => {
        const o = document.createElement("option");
        o.value = name;
        o.textContent = name;
        sel.appendChild(o);
      });
    }
    fillSelect(mySel, mySet, "▼ 履歴から選択（任意）");
    fillSelect(oppSel, oppSet, "▼ 履歴から選択（任意）");
  }

  function toggleTypePanel(who) {
    const selfPanel = document.getElementById("selfTypePanel");
    const oppPanel = document.getElementById("oppTypePanel");
    if (who === "self") {
      const open = !selfPanel.classList.contains("open");
      selfPanel.classList.toggle("open", open);
      oppPanel.classList.remove("open");
    } else {
      const open = !oppPanel.classList.contains("open");
      oppPanel.classList.toggle("open", open);
      selfPanel.classList.remove("open");
    }
  }

  function selectType(who, type) {
    if (who === "self") {
      document.getElementById("typeInput").value = type;
      updateSelfPreview();
      document.getElementById("selfTypePanel").classList.remove("open");
    } else {
      document.getElementById("opponentTypeInput").value = type;
      updateOpponentPreview();
      document.getElementById("oppTypePanel").classList.remove("open");
    }
    updateAIPrediction();
  }

  function updateSelfPreview() {
    const t = document.getElementById("typeInput").value;
    const c = document.getElementById("selfTypePreview");
    c.innerHTML = "";
    if (!t) {
      const span = document.createElement("span");
      span.textContent = "タップして属性を選択";
      c.appendChild(span);
      return;
    }
    const src = typeIconSrc(t);
    if (src) {
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.className = "type-icon";
      c.appendChild(img);
    }
  }

  function updateOpponentPreview() {
    const t = document.getElementById("opponentTypeInput").value;
    const c = document.getElementById("oppTypePreview");
    c.innerHTML = "";
    if (!t) {
      const span = document.createElement("span");
      span.textContent = "タップして属性を選択";
      c.appendChild(span);
      return;
    }
    const src = typeIconSrc(t);
    if (src) {
      const img = document.createElement("img");
      img.src = src;
      img.alt = "";
      img.className = "type-icon";
      c.appendChild(img);
    }
  }

  function sortedByDateAsc() {
    return records.slice().sort((a,b)=>{
      const ad = a.date || "";
      const bd = b.date || "";
      if (ad < bd) return -1;
      if (ad > bd) return 1;
      return (a.id||0)-(b.id||0);
    });
  }

  function calcSlumpPoints() {
    const sorted = sortedByDateAsc();
    let value = 0;
    const pts = [];
    for (const r of sorted) {
      if (r.result === "win") value += 1;
      else if (r.result === "lose") value -= 1;
      pts.push(value);
    }
    return pts;
  }

  function calcSlumpMap() {
    const sorted = sortedByDateAsc();
    let value = 0;
    const map = {};
    sorted.forEach((r,i)=>{
      if (r.result === "win") value += 1;
      else if (r.result === "lose") value -= 1;
      map[r.id] = value;
      r.battleNumber = i+1;
    });
    return map;
  }

  function calcStreaks() {
    let maxWin=0,maxLose=0,curWin=0,curLose=0;
    sortedByDateAsc().forEach(r=>{
      if (r.result === "win") {
        curWin++; curLose=0;
        if (curWin>maxWin) maxWin=curWin;
      } else if (r.result === "lose") {
        curLose++; curWin=0;
        if (curLose>maxLose) maxLose=curLose;
      } else {
        curWin=0; curLose=0;
      }
    });
    return {maxWin,maxLose,curWin,curLose};
  }

  function calcWinRatePoints() {
    const sorted = sortedByDateAsc();
    let w=0,l=0;
    const pts=[];
    for (const r of sorted) {
      if (r.result==="win") w++;
      else if (r.result==="lose") l++;
      const b = w+l;
      const rate = b===0?0:(w/b*100);
      pts.push(rate);
    }
    return pts;
  }

  function renderSlumpGraph() {
    const canvas = document.getElementById("slumpCanvas");
    const info = document.getElementById("slumpInfo");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");

    const rect = canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    canvas.width = width;
    canvas.height = height;

    ctx.clearRect(0,0,width,height);

    const points = calcSlumpPoints();
    const {maxWin,maxLose,curWin,curLose} = calcStreaks();

    const maxWinEl = document.getElementById("maxWinText");
    const maxLoseEl = document.getElementById("maxLoseText");
    const curWinEl = document.getElementById("curWinText");
    const curLoseEl = document.getElementById("curLoseText");

    if (maxWinEl) {
      maxWinEl.textContent = `${maxWin}連勝`;
      maxWinEl.style.color = maxWin>0 ? "#2563eb" : "#6b7280";
    }
    if (maxLoseEl) {
      maxLoseEl.textContent = `${maxLose}連敗`;
      maxLoseEl.style.color = maxLose>=2 ? "#dc2626" : "#6b7280";
    }
    if (curWinEl) {
      curWinEl.textContent = `${curWin}連勝`;
      curWinEl.style.color = curWin>0 ? "#2563eb" : "#6b7280";
    }
    if (curLoseEl) {
      curLoseEl.textContent = `${curLose}連敗`;
      curLoseEl.style.color = curLose>=2 ? "#dc2626" : "#6b7280";
    }

    if (!points.length) {
      if (info) {
        info.textContent = "まだデータがありません";
        info.style.color = "#6b7280";
      }
      ctx.fillStyle = "#9ca3af";
      ctx.font = "12px -apple-system, BlinkMacSystemFont, sans-serif";
      ctx.fillText("まだデータがありません", 10, height/2);
      return;
    } else {
      const last = points[points.length-1];
      const sign = last>0?"+":"";
      if (info) {
        info.textContent = `現在の累計：${sign}${last}`;
        info.style.color = last>0 ? "#2563eb" : last<0 ? "#dc2626" : "#6b7280";
      }
    }

    const maxVal = Math.max(...points,0);
    const minVal = Math.min(...points,0);
    const range = Math.max(maxVal-minVal,1);

    const padding = 32;
    const usableW = width - padding*2;
    const usableH = height - padding*2;

    ctx.fillStyle = "#f9fafb";
    ctx.fillRect(padding, padding, usableW, usableH);

    ctx.setLineDash([4,4]);
    ctx.strokeStyle = "#e5e7eb";
    ctx.lineWidth = 1;
    const gridCount = 4;
    for (let i=0;i<=gridCount;i++){
      const y = padding + usableH*i/gridCount;
      ctx.beginPath();
      ctx.moveTo(padding,y);
      ctx.lineTo(width-padding,y);
      ctx.stroke();
    }
    ctx.setLineDash([]);

    const zeroY = padding + usableH*(maxVal/range);
    ctx.strokeStyle = "#4b5563";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(padding,zeroY);
    ctx.lineTo(width-padding,zeroY);
    ctx.stroke();

    function pointToXY(idx,v){
      const ratio = points.length===1?0.5:idx/(points.length-1);
      const x = padding + usableW*ratio;
      const y = padding + usableH*((maxVal-v)/range);
      return {x,y};
    }

    ctx.lineWidth = 2;
    for (let i=1;i<points.length;i++){
      const v1 = points[i-1];
      const v2 = points[i];
      const {x:x1,y:y1} = pointToXY(i-1,v1);
      const {x:x2,y:y2} = pointToXY(i,v2);
      const avg = (v1+v2)/2;
      ctx.strokeStyle = avg>=0 ? "#2563eb" : "#dc2626";
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }

    for (let i=0;i<points.length;i++){
      const v = points[i];
      const {x,y} = pointToXY(i,v);
      ctx.fillStyle = v>=0 ? "#2563eb" : "#dc2626";
      ctx.beginPath();
      ctx.arc(x,y,3,0,Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = "#6b7280";
    ctx.font = "10px -apple-system, BlinkMacSystemFont, sans-serif";
    for (let i=0;i<points.length;i++){
      const {x} = pointToXY(i,points[i]);
      ctx.fillText(String(i+1), x-3, height-5);
    }

    const minY = Math.floor(minVal);
    const maxY = Math.ceil(maxVal);
    for (let v=minY; v<=maxY; v++){
      const y = padding + usableH*((maxVal - v)/range);
      ctx.fillText(String(v), 6, y+3);
    }
  }

  function renderWinRateGraph() {
    const canvas = document.getElementById("winrateCanvas");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");

    const rect = canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    canvas.width = width;
    canvas.height = height;

    ctx.clearRect(0,0,width,height);

    const points = calcWinRatePoints();
    if (points.length===0 || points.every(v=>v===0)){
      ctx.fillStyle = "#9ca3af";
      ctx.font = "12px -apple-system, BlinkMacSystemFont, sans-serif";
      ctx.fillText("勝ち負けの対戦がまだありません", 10, height/2);
      return;
    }

    const maxVal = Math.max(...points,100);
    const minVal = 0;
    const range = Math.max(maxVal-minVal,1);

    const padding = 32;
    const usableW = width - padding*2;
    const usableH = height - padding*2;

    ctx.fillStyle = "#f9fafb";
    ctx.fillRect(padding,padding,usableW,usableH);

    const levels = [0,25,50,75,100];
    ctx.font = "10px -apple-system, BlinkMacSystemFont, sans-serif";
    ctx.fillStyle = "#6b7280";
    levels.forEach(lv=>{
      const ratio = (lv-minVal)/range;
      const y = padding + usableH*(1-ratio);
      if (lv===50){
        ctx.setLineDash([]);
        ctx.strokeStyle = "#4b5563";
        ctx.lineWidth = 3;
      } else {
        ctx.setLineDash([4,4]);
        ctx.strokeStyle = "#e5e7eb";
        ctx.lineWidth = 1;
      }
      ctx.beginPath();
      ctx.moveTo(padding,y);
      ctx.lineTo(width-padding,y);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillText(lv+"%", 4, y+3);
    });

    function pointToXY(idx,v){
      const ratio = points.length===1?0.5:idx/(points.length-1);
      const x = padding + usableW*ratio;
      const yRatio = (v-minVal)/range;
      const y = padding + usableH*(1-yRatio);
      return {x,y};
    }

    ctx.lineWidth = 2;
    for (let i=1;i<points.length;i++){
      const v1=points[i-1];
      const v2=points[i];
      const {x:x1,y:y1} = pointToXY(i-1,v1);
      const {x:x2,y:y2} = pointToXY(i,v2);
      const avg = (v1+v2)/2;
      ctx.strokeStyle = avg>=50 ? "#2563eb" : "#dc2626";
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }

    points.forEach((v,i)=>{
      const {x,y} = pointToXY(i,v);
      ctx.beginPath();
      ctx.arc(x,y,3,0,Math.PI*2);
      ctx.fillStyle = v>=50 ? "#2563eb" : "#dc2626";
      ctx.fill();
    });

    ctx.fillStyle = "#6b7280";
    ctx.font = "10px -apple-system, BlinkMacSystemFont, sans-serif";
    points.forEach((v,i)=>{
      const {x} = pointToXY(i,v);
      ctx.fillText(String(i+1), x-3, height-5);
    });
  }

  function addRecord() {
    const date = document.getElementById("dateInput").value;
    const myDeck = document.getElementById("myDeckInput").value.trim();
    const opponentDeck = document.getElementById("opponentDeckInput").value.trim();
    const type = document.getElementById("typeInput").value;
    const opponentType = document.getElementById("opponentTypeInput").value;
    const result = document.getElementById("resultInput").value;
    const order = document.getElementById("orderInput").value;
    const memo = document.getElementById("memoInput").value.trim();

    if (editingId !== null) {
      const idx = records.findIndex(r=>r.id===editingId);
      if (idx!==-1){
        records[idx] = {...records[idx], date,myDeck,opponentDeck,type,opponentType,result,order,memo};
      }
    } else {
      const rec = {id:Date.now(),date,myDeck,opponentDeck,type,opponentType,result,order,memo};
      records.push(rec);
    }

    saveData();
    editingId = null;
    const btn = document.getElementById("submitButton");
    if (btn) btn.textContent = "記録を追加";
    render();
    clearForm();
  }

  function clearForm() {
    const today = new Date().toISOString().slice(0,10);
    document.getElementById("dateInput").value = today;
    document.getElementById("myDeckInput").value = "";
    document.getElementById("opponentDeckInput").value = "";
    document.getElementById("myDeckPreset").value = "";
    document.getElementById("opponentDeckPreset").value = "";
    document.getElementById("typeInput").value = "";
    document.getElementById("opponentTypeInput").value = "";
    document.getElementById("resultInput").value = "win";
    document.getElementById("orderInput").value = "first";
    document.getElementById("memoInput").value = "";
    editingId = null;
    const btn = document.getElementById("submitButton");
    if (btn) btn.textContent = "記録を追加";
    updateSelfPreview();
    updateOpponentPreview();
    updateResultColor();
    updateAIPrediction();
    document.getElementById("selfTypePanel").classList.remove("open");
    document.getElementById("oppTypePanel").classList.remove("open");
  }

  function editRecord(id) {
    const rec = records.find(r=>r.id===id);
    if (!rec) return;
    editingId = id;

    document.getElementById("dateInput").value = rec.date || "";
    document.getElementById("myDeckInput").value = rec.myDeck || "";
    document.getElementById("opponentDeckInput").value = rec.opponentDeck || "";
    document.getElementById("myDeckPreset").value = "";
    document.getElementById("opponentDeckPreset").value = "";
    document.getElementById("typeInput").value = rec.type || "";
    document.getElementById("opponentTypeInput").value = rec.opponentType || "";
    document.getElementById("resultInput").value = rec.result || "win";
    document.getElementById("orderInput").value = rec.order || "first";
    document.getElementById("memoInput").value = rec.memo || "";

    updateSelfPreview();
    updateOpponentPreview();
    updateResultColor();
    updateAIPrediction();
    document.getElementById("selfTypePanel").classList.remove("open");
    document.getElementById("oppTypePanel").classList.remove("open");

    const btn = document.getElementById("submitButton");
    if (btn) btn.textContent = "記録を更新";
    window.scrollTo({top:0,behavior:"smooth"});
  }

  function deleteRecord(id) {
    if (!confirm("この記録を削除しますか？")) return;
    records = records.filter(r=>r.id!==id);
    saveData();
    clearForm();
    render();
  }

  function clearAll() {
    if (!confirm("すべての記録を削除しますか？")) return;
    records = [];
    saveData();
    clearForm();
    render();
  }

  function renderTable() {
    const tbody = document.querySelector("#recordsTable tbody");
    tbody.innerHTML = "";
    if (records.length===0){
      document.getElementById("countText").textContent="0件";
      return;
    }
    const slumpMap = calcSlumpMap();
    const sortedDesc = sortedByDateAsc().slice().reverse();

    sortedDesc.forEach(rec=>{
      const tr = document.createElement("tr");

      const tdDate=document.createElement("td");
      tdDate.textContent = `${rec.battleNumber}戦目  ${formatDate(rec.date)}`;

      const tdMy=document.createElement("td");
      const spanMy=document.createElement("span");

      const cardSrc = deckCardSrc(rec.myDeck);
      if (cardSrc) {
        const cimg = document.createElement("img");
        cimg.src = cardSrc;
        cimg.alt = "";
        cimg.className = "deck-card-icon";
        spanMy.appendChild(cimg);
      }
      const mySrc=typeIconSrc(rec.type);
      if (mySrc){
        const img=document.createElement("img");
        img.src=mySrc; img.alt=""; img.className="type-icon";
        spanMy.appendChild(img);
      }
      spanMy.appendChild(document.createTextNode(rec.myDeck||""));
      tdMy.appendChild(spanMy);

      const tdOpp=document.createElement("td");
      const spanOpp=document.createElement("span");
      const oppCardSrc = deckCardSrc(rec.opponentDeck);
      if (oppCardSrc) {
        const cimg2 = document.createElement("img");
        cimg2.src = oppCardSrc;
        cimg2.alt = "";
        cimg2.className = "deck-card-icon";
        spanOpp.appendChild(cimg2);
      }
      const oppSrc=typeIconSrc(rec.opponentType);
      if (oppSrc){
        const img2=document.createElement("img");
        img2.src=oppSrc; img2.alt=""; img2.className="type-icon";
        spanOpp.appendChild(img2);
      }
      spanOpp.appendChild(document.createTextNode(rec.opponentDeck||""));
      tdOpp.appendChild(spanOpp);

      const tdRes=document.createElement("td");
      const spanR=document.createElement("span");
      spanR.textContent = resultLabel(rec.result);
      spanR.className = resultClass(rec.result);
      const spanO=document.createElement("span");
      spanO.textContent = orderLabel(rec.order);
      spanO.className = "tag-order";
      tdRes.appendChild(spanR);
      tdRes.appendChild(spanO);

      const tdSlump=document.createElement("td");
      const v = slumpMap[rec.id] ?? 0;
      const sign = v>0?"+":"";
      tdSlump.textContent = sign+v;
      tdSlump.className = v>0?"slump-plus":v<0?"slump-minus":"slump-zero";

      const tdMemo=document.createElement("td");
      tdMemo.textContent = rec.memo || "";

      const tdAct=document.createElement("td");
      const editBtn=document.createElement("button");
      editBtn.textContent="編集";
      editBtn.className="btn-sub";
      editBtn.style.fontSize="11px";
      editBtn.style.marginRight="4px";
      editBtn.onclick=()=>editRecord(rec.id);

      const delBtn=document.createElement("button");
      delBtn.textContent="削除";
      delBtn.className="btn-sub";
      delBtn.style.fontSize="11px";
      delBtn.onclick=()=>deleteRecord(rec.id);

      tdAct.appendChild(editBtn);
      tdAct.appendChild(delBtn);

      tr.appendChild(tdDate);
      tr.appendChild(tdMy);
      tr.appendChild(tdOpp);
      tr.appendChild(tdRes);
      tr.appendChild(tdSlump);
      tr.appendChild(tdMemo);
      tr.appendChild(tdAct);

      tbody.appendChild(tr);
    });

    document.getElementById("countText").textContent=`${records.length}件`;
  }

  function renderDeckStats() {
    const tbody=document.querySelector("#deckStatsTable tbody");
    tbody.innerHTML="";
    if (records.length===0) return;

    const stats={};
    records.forEach(r=>{
      const key=r.myDeck||"（名称未入力）";
      if (!stats[key]) stats[key]={win:0,lose:0,draw:0,total:0};
      stats[key].total++;
      if (r.result==="win") stats[key].win++;
      else if (r.result==="lose") stats[key].lose++;
      else if (r.result==="draw") stats[key].draw++;
    });

    Object.keys(stats).sort().forEach(name=>{
      const s=stats[name];
      const battle=s.win+s.lose;
      const rate=battle===0?0:(s.win/battle*100);

      const tr=document.createElement("tr");
      const tdName=document.createElement("td");
      tdName.textContent=name;
      const tdTotal=document.createElement("td");
      tdTotal.textContent=s.total;
      const tdW=document.createElement("td");
      tdW.textContent=s.win;
      const tdL=document.createElement("td");
      tdL.textContent=s.lose;
      const tdD=document.createElement("td");
      tdD.textContent=s.draw;
      const tdRate=document.createElement("td");
      tdRate.textContent=rate.toFixed(1)+"%";

      let color="#6b7280";
      if (battle>0){
        if (rate>=55) color="#2563eb";
        else if (rate<=45) color="#dc2626";
      }
      tdRate.style.color=color;

      tr.appendChild(tdName);
      tr.appendChild(tdTotal);
      tr.appendChild(tdW);
      tr.appendChild(tdL);
      tr.appendChild(tdD);
      tr.appendChild(tdRate);
      tbody.appendChild(tr);
    });
  }

  function typeHeaderHTML(key){
    const src=typeIconSrc(key);
    const label=TYPE_LABEL[key]||"";
    return `<img src="${src}" class="type-icon" alt="">${label}`;
  }

  function renderTypeMatrix(){
    const table=document.getElementById("typeMatrixTable");
    if (!table) return;

    if (records.length===0){
      table.innerHTML="<tbody><tr><td class='muted'>まだデータがありません</td></tr></tbody>";
      return;
    }

    const matrix={};
    records.forEach(r=>{
      const self=r.type;
      const opp=r.opponentType;
      if (!self || !opp) return;
      const key=self+"|"+opp;
      if (!matrix[key]) matrix[key]={win:0,lose:0,draw:0,total:0};
      matrix[key].total++;
      if (r.result==="win") matrix[key].win++;
      else if (r.result==="lose") matrix[key].lose++;
      else if (r.result==="draw") matrix[key].draw++;
    });

    let html="<thead><tr><th>自＼相</th>";
    TYPE_KEYS.forEach(k=>{ html+=`<th>${typeHeaderHTML(k)}</th>`; });
    html+="</tr></thead><tbody>";

    TYPE_KEYS.forEach(selfKey=>{
      html+="<tr>";
      html+=`<th>${typeHeaderHTML(selfKey)}</th>`;
      TYPE_KEYS.forEach(oppKey=>{
        const key=selfKey+"|"+oppKey;
        const cell=matrix[key];
        if (!cell || cell.total===0){
          html+="<td>－</td>";
        } else {
          const battle=cell.win+cell.lose;
          const rate=battle===0?0:(cell.win/battle*100);
          html+=`<td>${rate.toFixed(1)}%<br>(${cell.win}/${cell.total})</td>`;
        }
      });
      html+="</tr>";
    });
    html+="</tbody>";
    table.innerHTML=html;
  }

  function setRateColor(id, rate, hasBattle) {
    const el=document.getElementById(id);
    if (!el) return;
    if (!hasBattle){
      el.style.color="#6b7280";
      return;
    }
    el.style.color = rate>=50 ? "#2563eb" : "#dc2626";
  }

  function renderStats() {
    const wins=records.filter(r=>r.result==="win").length;
    const loses=records.filter(r=>r.result==="lose").length;
    const draws=records.filter(r=>r.result==="draw").length;
    const total=records.length;
    const battle=wins+loses;
    const winRate=battle===0?0:(wins/battle*100);

    document.getElementById("totalText").textContent=`${total}戦`;
    document.getElementById("wlText").textContent=`勝${wins} / 負${loses} / 分${draws}`;
    document.getElementById("winRateText").textContent=winRate.toFixed(1)+"%";
    setRateColor("winRateText", winRate, battle>0);

    const first=records.filter(r=>r.order==="first");
    const second=records.filter(r=>r.order==="second");
    const fW=first.filter(r=>r.result==="win").length;
    const fL=first.filter(r=>r.result==="lose").length;
    const sW=second.filter(r=>r.result==="win").length;
    const sL=second.filter(r=>r.result==="lose").length;
    const fTotal=fW+fL;
    const sTotal=sW+sL;
    const fRate=fTotal===0?0:(fW/fTotal*100);
    const sRate=sTotal===0?0:(sW/sTotal*100);

    document.getElementById("firstRateText").textContent=fRate.toFixed(1)+"%";
    document.getElementById("firstDetailText").textContent=`${fW}勝 ${fL}敗`;
    document.getElementById("secondRateText").textContent=sRate.toFixed(1)+"%";
    document.getElementById("secondDetailText").textContent=`${sW}勝 ${sL}敗`;

    setRateColor("firstRateText", fRate, fTotal>0);
    setRateColor("secondRateText", sRate, sTotal>0);
  }

  // ---------- AI予想 用の計算 ----------
  function calcPredictedWinRate(myDeck, oppDeck, type, opponentType, order) {
    if (!records.length) return null;

    const wins = records.filter(r=>r.result==="win").length;
    const loses = records.filter(r=>r.result==="lose").length;
    const totalBattle = wins + loses;
    if (totalBattle === 0) return null;

    const baseRate = wins / totalBattle * 100;

    let pairRate = null;
    if (myDeck && oppDeck) {
      const pair = records.filter(r=>r.myDeck===myDeck && r.opponentDeck===oppDeck);
      const pw = pair.filter(r=>r.result==="win").length;
      const pl = pair.filter(r=>r.result==="lose").length;
      const pb = pw + pl;
      if (pb >= 3) {
        pairRate = pw / pb * 100;
      }
    }

    let typeRate = null;
    if (type && opponentType) {
      const tlist = records.filter(r=>r.type===type && r.opponentType===opponentType);
      const tw = tlist.filter(r=>r.result==="win").length;
      const tl = tlist.filter(r=>r.result==="lose").length;
      const tb = tw + tl;
      if (tb >= 5) {
        typeRate = tw / tb * 100;
      }
    }

    let orderRate = null;
    if (order) {
      const olist = records.filter(r=>r.order===order);
      const ow = olist.filter(r=>r.result==="win").length;
      const ol = olist.filter(r=>r.result==="lose").length;
      const ob = ow + ol;
      if (ob >= 5) {
        orderRate = ow / ob * 100;
      }
    }

    const rates = [baseRate];
    const weights = [1.0];

    if (pairRate !== null) {
      rates.push(pairRate);
      weights.push(1.2);
    }
    if (typeRate !== null) {
      rates.push(typeRate);
      weights.push(0.8);
    }
    if (orderRate !== null) {
      rates.push(orderRate);
      weights.push(0.5);
    }

    let num = 0;
    let den = 0;
    for (let i=0;i<rates.length;i++){
      num += rates[i] * weights[i];
      den += weights[i];
    }
    if (den === 0) return baseRate;

    let pred = num / den;
    if (pred < 5) pred = 5;
    if (pred > 95) pred = 95;
    return pred;
  }

  function updateAIPrediction() {
    const myDeck = document.getElementById("myDeckInput").value.trim();
    const oppDeck = document.getElementById("opponentDeckInput").value.trim();
    const type = document.getElementById("typeInput").value;
    const opponentType = document.getElementById("opponentTypeInput").value;
    const order = document.getElementById("orderInput").value;

    const textEl = document.getElementById("aiPredictionText");
    const barEl  = document.getElementById("aiPredictionBar");
    if (!textEl || !barEl) return;

    const p = calcPredictedWinRate(myDeck, oppDeck, type, opponentType, order);

    if (p == null) {
      textEl.textContent = "条件を入力すると予想が表示されます。";
      barEl.style.width = "0%";
      barEl.style.background = "#9ca3af";
      return;
    }

    let comment = "";
    if (p >= 70) comment = "かなり有利";
    else if (p >= 55) comment = "やや有利";
    else if (p >= 45) comment = "五分";
    else if (p >= 30) comment = "やや不利";
    else comment = "かなり不利";

    textEl.textContent = `予想勝率：${p.toFixed(1)}%（${comment}）`;
    barEl.style.width = p.toFixed(1) + "%";
    barEl.style.background = p >= 50 ? "#2563eb" : "#dc2626";
  }

  // ------------ バックアップ / 復元 ------------
  function exportBackup() {
    if (!records.length) {
      alert("まだバックアップするデータがありません。");
      return;
    }
    const data = JSON.stringify(records, null, 2);
    const now = new Date();
    const y = now.getFullYear();
    const m = ("0" + (now.getMonth() + 1)).slice(-2);
    const d = ("0" + now.getDate()).slice(-2);

    const blob = new Blob([data], { type: "application/json" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = `pokepoke_backup_${y}${m}${d}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function triggerImport() {
    const input = document.getElementById("importFile");
    if (input) input.click();
  }

  function importBackup(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (e) {
      try {
        const json = JSON.parse(e.target.result);
        if (!Array.isArray(json)) {
          alert("バックアップデータの形式が違います。");
          return;
        }
        if (!confirm("現在のデータを上書きして復元しますか？")) {
          return;
        }
        records = json;
        saveData();
        render();
        alert("復元が完了しました。");
      } catch (err) {
        console.error(err);
        alert("バックアップファイルの読み込みに失敗しました。");
      }
    };
    reader.readAsText(file, "utf-8");
  }
  // ------------ ここまで ------------

  function render() {
    renderTable();
    renderStats();
    renderWinRateGraph();
    renderSlumpGraph();
    renderDeckStats();
    renderTypeMatrix();
    renderDeckPresets();
    updateAIPrediction();
  }

  function updateResultColor() {
    const sel=document.getElementById("resultInput");
    if (!sel) return;
    let color="#6b7280";
    if (sel.value==="win") color="#1d4ed8";
    else if (sel.value==="lose") color="#b91c1c";
    sel.style.color=color;
  }

  loadData();
  window.addEventListener("load",()=>{
    const today=new Date().toISOString().slice(0,10);
    const dateInput=document.getElementById("dateInput");
    if (dateInput) dateInput.value=today;
    updateSelfPreview();
    updateOpponentPreview();
    updateResultColor();
    render();

    // 入力のたびにAI予想を更新
    const myDeckInput = document.getElementById("myDeckInput");
    const oppDeckInput = document.getElementById("opponentDeckInput");
    const orderInput = document.getElementById("orderInput");

    if (myDeckInput) myDeckInput.addEventListener("input", updateAIPrediction);
    if (oppDeckInput) oppDeckInput.addEventListener("input", updateAIPrediction);
    if (orderInput) orderInput.addEventListener("change", updateAIPrediction);
  });
</script>
</body>
</html>
